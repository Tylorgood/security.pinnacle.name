"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AggregateRatingJsonLd: () => AggregateRatingJsonLd,
  ArticleJsonLd: () => ArticleJsonLd,
  BreadcrumbJsonLd: () => BreadcrumbJsonLd,
  CarouselJsonLd: () => CarouselJsonLd,
  ClaimReviewJsonLd: () => ClaimReviewJsonLd,
  CourseJsonLd: () => CourseJsonLd,
  CreativeWorkJsonLd: () => CreativeWorkJsonLd,
  DatasetJsonLd: () => DatasetJsonLd,
  DiscussionForumPostingJsonLd: () => DiscussionForumPostingJsonLd,
  EmployerAggregateRatingJsonLd: () => EmployerAggregateRatingJsonLd,
  EventJsonLd: () => EventJsonLd,
  FAQJsonLd: () => FAQJsonLd,
  HowToJsonLd: () => HowToJsonLd,
  ImageJsonLd: () => ImageJsonLd,
  JobPostingJsonLd: () => JobPostingJsonLd,
  JsonLdScript: () => JsonLdScript,
  LocalBusinessJsonLd: () => LocalBusinessJsonLd,
  MerchantReturnPolicyJsonLd: () => MerchantReturnPolicyJsonLd,
  MovieCarouselJsonLd: () => MovieCarouselJsonLd,
  OrganizationJsonLd: () => OrganizationJsonLd,
  ProductJsonLd: () => ProductJsonLd,
  ProfilePageJsonLd: () => ProfilePageJsonLd,
  QuizJsonLd: () => QuizJsonLd,
  RecipeJsonLd: () => RecipeJsonLd,
  ReviewJsonLd: () => ReviewJsonLd,
  SoftwareApplicationJsonLd: () => SoftwareApplicationJsonLd,
  VacationRentalJsonLd: () => VacationRentalJsonLd,
  VideoJsonLd: () => VideoJsonLd,
  processors: () => processors_export_exports
});
module.exports = __toCommonJS(src_exports);

// src/utils/stringify.ts
var safeJsonLdReplacer = /* @__PURE__ */ (() => {
  return (_, value) => {
    switch (typeof value) {
      case "object":
        if (value === null) {
          return void 0;
        }
        return value;
      // JSON.stringify will recursively call replacer.
      case "number":
      case "boolean":
      case "bigint":
      case "string":
        return value;
      // Return all primitive values as-is
      default: {
        isNever(value);
        return void 0;
      }
    }
  };
})();
function isNever(_) {
}
var stringify = (data) => {
  const jsonString = JSON.stringify(data, safeJsonLdReplacer);
  return jsonString.replace(/<\/script>/gi, "\\u003C/script>").replace(/<!--/g, "\\u003C!--").replace(/-->/g, "--\\u003E");
};

// src/core/JsonLdScript.tsx
var import_jsx_runtime = require("react/jsx-runtime");
function JsonLdScript({
  data,
  id,
  scriptKey
}) {
  if (data === null || data === void 0) {
    return null;
  }
  const jsonString = stringify(data);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "script",
    {
      type: "application/ld+json",
      id: id || scriptKey,
      "data-testid": id,
      dangerouslySetInnerHTML: { __html: jsonString }
    },
    scriptKey
  );
}

// src/utils/processors.export.ts
var processors_export_exports = {};
__export(processors_export_exports, {
  processAccommodation: () => processAccommodation,
  processAddress: () => processAddress,
  processAggregateOffer: () => processAggregateOffer,
  processAggregateRating: () => processAggregateRating,
  processAppearance: () => processAppearance,
  processApplicantLocationRequirements: () => processApplicantLocationRequirements,
  processAuthor: () => processAuthor,
  processBedDetails: () => processBedDetails,
  processBrand: () => processBrand,
  processBreadcrumbItem: () => processBreadcrumbItem,
  processBroadcastEvent: () => processBroadcastEvent,
  processCertification: () => processCertification,
  processClaim: () => processClaim,
  processClaimReviewRating: () => processClaimReviewRating,
  processClip: () => processClip,
  processComment: () => processComment,
  processContactPoint: () => processContactPoint,
  processCreator: () => processCreator,
  processDataCatalog: () => processDataCatalog,
  processDataDownload: () => processDataDownload,
  processDefinedRegion: () => processDefinedRegion,
  processDirector: () => processDirector,
  processEducationRequirements: () => processEducationRequirements,
  processEstimatedCost: () => processEstimatedCost,
  processExperienceRequirements: () => processExperienceRequirements,
  processFeatureList: () => processFeatureList,
  processFunder: () => processFunder,
  processGeo: () => processGeo,
  processHiringOrganization: () => processHiringOrganization,
  processHowToDirection: () => processHowToDirection,
  processHowToSection: () => processHowToSection,
  processHowToStep: () => processHowToStep,
  processHowToSupply: () => processHowToSupply,
  processHowToTip: () => processHowToTip,
  processHowToTool: () => processHowToTool,
  processHowToYield: () => processHowToYield,
  processIdentifier: () => processIdentifier,
  processImage: () => processImage,
  processInstruction: () => processInstruction,
  processInteractionStatistic: () => processInteractionStatistic,
  processIsPartOf: () => processIsPartOf,
  processItemReviewed: () => processItemReviewed,
  processJobLocation: () => processJobLocation,
  processJobPropertyValue: () => processJobPropertyValue,
  processLicense: () => processLicense,
  processLocationFeatureSpecification: () => processLocationFeatureSpecification,
  processLogo: () => processLogo,
  processMainEntityOfPage: () => processMainEntityOfPage,
  processMemberProgram: () => processMemberProgram,
  processMemberProgramTier: () => processMemberProgramTier,
  processMembershipPointsEarned: () => processMembershipPointsEarned,
  processMerchantReturnPolicy: () => processMerchantReturnPolicy,
  processMonetaryAmount: () => processMonetaryAmount,
  processNumberOfEmployees: () => processNumberOfEmployees,
  processNutrition: () => processNutrition,
  processOffer: () => processOffer,
  processOfferShippingDetails: () => processOfferShippingDetails,
  processOpeningHours: () => processOpeningHours,
  processOrganization: () => processOrganization,
  processOrganizer: () => processOrganizer,
  processPeopleAudience: () => processPeopleAudience,
  processPerformer: () => processPerformer,
  processPlace: () => processPlace,
  processPriceSpecification: () => processPriceSpecification,
  processProductItemList: () => processProductItemList,
  processProductOffer: () => processProductOffer,
  processProductReview: () => processProductReview,
  processProductVariant: () => processProductVariant,
  processProvider: () => processProvider,
  processPublisher: () => processPublisher,
  processQuantitativeValue: () => processQuantitativeValue,
  processRating: () => processRating,
  processReturnPolicySeasonalOverride: () => processReturnPolicySeasonalOverride,
  processReview: () => processReview,
  processSchemaType: () => processSchemaType,
  processScreenshot: () => processScreenshot,
  processSeekToAction: () => processSeekToAction,
  processSharedContent: () => processSharedContent,
  processShippingDeliveryTime: () => processShippingDeliveryTime,
  processSimpleMonetaryAmount: () => processSimpleMonetaryAmount,
  processSizeSpecification: () => processSizeSpecification,
  processSpatialCoverage: () => processSpatialCoverage,
  processStep: () => processStep,
  processThreeDModel: () => processThreeDModel,
  processTierBenefit: () => processTierBenefit,
  processTierRequirement: () => processTierRequirement,
  processUnitPriceSpecification: () => processUnitPriceSpecification,
  processVariesBy: () => processVariesBy,
  processVideo: () => processVideo,
  processWebPageElement: () => processWebPageElement
});

// src/utils/processors.ts
var SCHEMA_TYPES = {
  PERSON: "Person",
  ORGANIZATION: "Organization",
  IMAGE_OBJECT: "ImageObject",
  POSTAL_ADDRESS: "PostalAddress",
  CONTACT_POINT: "ContactPoint",
  QUANTITATIVE_VALUE: "QuantitativeValue",
  GEO_COORDINATES: "GeoCoordinates",
  GEO_SHAPE: "GeoShape",
  OPENING_HOURS: "OpeningHoursSpecification",
  REVIEW: "Review",
  RATING: "Rating",
  AGGREGATE_RATING: "AggregateRating",
  MERCHANT_RETURN_POLICY: "MerchantReturnPolicy",
  MERCHANT_RETURN_POLICY_SEASONAL_OVERRIDE: "MerchantReturnPolicySeasonalOverride",
  MONETARY_AMOUNT: "MonetaryAmount",
  VIDEO_OBJECT: "VideoObject",
  INTERACTION_COUNTER: "InteractionCounter",
  BRAND: "Brand",
  CREDIT_CARD: "CreditCard",
  UNIT_PRICE_SPECIFICATION: "UnitPriceSpecification",
  MEMBER_PROGRAM: "MemberProgram",
  MEMBER_PROGRAM_TIER: "MemberProgramTier",
  BED_DETAILS: "BedDetails",
  LOCATION_FEATURE: "LocationFeatureSpecification",
  ACCOMMODATION: "Accommodation",
  PLACE: "Place",
  PERFORMING_GROUP: "PerformingGroup",
  OFFER: "Offer",
  AGGREGATE_OFFER: "AggregateOffer",
  PRICE_SPECIFICATION: "PriceSpecification",
  ITEM_LIST: "ItemList",
  LIST_ITEM: "ListItem",
  PRODUCT: "Product",
  PRODUCT_GROUP: "ProductGroup",
  NUTRITION_INFORMATION: "NutritionInformation",
  HOW_TO_STEP: "HowToStep",
  HOW_TO_SECTION: "HowToSection",
  HOW_TO_SUPPLY: "HowToSupply",
  HOW_TO_TOOL: "HowToTool",
  HOW_TO_DIRECTION: "HowToDirection",
  HOW_TO_TIP: "HowToTip",
  PROPERTY_VALUE: "PropertyValue",
  CREATIVE_WORK: "CreativeWork",
  DATA_DOWNLOAD: "DataDownload",
  DATA_CATALOG: "DataCatalog",
  COUNTRY: "Country",
  STATE: "State",
  EDUCATIONAL_CREDENTIAL: "EducationalOccupationalCredential",
  OCCUPATIONAL_EXPERIENCE: "OccupationalExperienceRequirements",
  COMMENT: "Comment",
  WEB_PAGE: "WebPage",
  WEB_PAGE_ELEMENT: "WebPageElement",
  CLAIM: "Claim",
  CERTIFICATION: "Certification",
  PEOPLE_AUDIENCE: "PeopleAudience",
  SIZE_SPECIFICATION: "SizeSpecification",
  THREE_D_MODEL: "3DModel",
  DEFINED_REGION: "DefinedRegion",
  SHIPPING_DELIVERY_TIME: "ShippingDeliveryTime",
  OFFER_SHIPPING_DETAILS: "OfferShippingDetails"
};
function hasType(obj) {
  return obj !== null && typeof obj === "object" && "@type" in obj;
}
function isString(value) {
  return typeof value === "string";
}
function processSchemaType(value, schemaType, stringHandler, numberHandler) {
  if (isString(value) && stringHandler) {
    return { "@type": schemaType, ...stringHandler(value) };
  }
  if (typeof value === "number" && numberHandler) {
    return { "@type": schemaType, ...numberHandler(value) };
  }
  if (hasType(value)) {
    return value;
  }
  if (typeof value === "object" && value !== null) {
    return { "@type": schemaType, ...value };
  }
  return { "@type": schemaType };
}
function processOrganizationFields(org) {
  if (org.logo && !isString(org.logo)) {
    org.logo = processLogo(org.logo);
  }
  if (org.address && !isString(org.address)) {
    if (Array.isArray(org.address)) {
      org.address = org.address.map(
        (addr) => isString(addr) ? addr : processAddress(addr)
      );
    } else {
      org.address = processAddress(org.address);
    }
  }
  if (org.contactPoint) {
    if (Array.isArray(org.contactPoint)) {
      org.contactPoint = org.contactPoint.map(processContactPoint);
    } else {
      org.contactPoint = processContactPoint(org.contactPoint);
    }
  }
}
function processAuthor(author) {
  if (isString(author)) {
    const orgIndicators = [
      "magazine",
      "publication",
      "company",
      "corporation",
      "corp",
      "inc",
      "llc",
      "ltd",
      "limited",
      "group",
      "foundation",
      "institute",
      "association",
      "society",
      "union",
      "times",
      "news",
      "press",
      "media",
      "network",
      "agency",
      "studio"
    ];
    const lowerName = author.toLowerCase();
    const isLikelyOrg = orgIndicators.some(
      (indicator) => lowerName.includes(indicator)
    );
    if (isLikelyOrg) {
      return {
        "@type": SCHEMA_TYPES.ORGANIZATION,
        name: author
      };
    }
    return {
      "@type": SCHEMA_TYPES.PERSON,
      name: author
    };
  }
  if (hasType(author)) {
    return author;
  }
  const hasOrgProperties = "logo" in author || "address" in author || "contactPoint" in author;
  if (hasOrgProperties) {
    const org = {
      "@type": SCHEMA_TYPES.ORGANIZATION,
      ...author
    };
    processOrganizationFields(org);
    return org;
  }
  return {
    "@type": SCHEMA_TYPES.PERSON,
    ...author
  };
}
function processImage(image) {
  if (isString(image)) {
    return image;
  }
  return processSchemaType(image, SCHEMA_TYPES.IMAGE_OBJECT);
}
function processAddress(address) {
  return processSchemaType(
    address,
    SCHEMA_TYPES.POSTAL_ADDRESS,
    (str) => ({ streetAddress: str }),
    void 0
  );
}
function processContactPoint(contactPoint) {
  return processSchemaType(
    contactPoint,
    SCHEMA_TYPES.CONTACT_POINT
  );
}
function processLogo(logo) {
  return processImage(logo);
}
function processNumberOfEmployees(numberOfEmployees) {
  return processSchemaType(
    numberOfEmployees,
    SCHEMA_TYPES.QUANTITATIVE_VALUE,
    void 0,
    (num) => ({ value: num })
  );
}
function processGeo(geo) {
  return processSchemaType(geo, SCHEMA_TYPES.GEO_COORDINATES);
}
function processOpeningHours(hours) {
  return processSchemaType(
    hours,
    SCHEMA_TYPES.OPENING_HOURS
  );
}
function processReview(review) {
  const processed = processSchemaType(
    review,
    SCHEMA_TYPES.REVIEW
  );
  if (review.reviewRating) {
    processed.reviewRating = processSchemaType(
      review.reviewRating,
      SCHEMA_TYPES.RATING
    );
  }
  if (review.author) {
    processed.author = processAuthor(review.author);
  }
  return processed;
}
function processBreadcrumbItem(item, position) {
  return {
    "@type": SCHEMA_TYPES.LIST_ITEM,
    position,
    ...item.name && { name: item.name },
    ...item.item && { item: item.item }
  };
}
function processPlace(location) {
  return processSchemaType(
    location,
    SCHEMA_TYPES.PLACE,
    (str) => ({
      name: str,
      address: {
        "@type": SCHEMA_TYPES.POSTAL_ADDRESS,
        streetAddress: str
      }
    }),
    void 0
  );
}
function processPerformer(performer) {
  if (isString(performer)) {
    return {
      "@type": SCHEMA_TYPES.PERFORMING_GROUP,
      name: performer
    };
  }
  if (hasType(performer)) {
    return performer;
  }
  const hasPersonProperties = "familyName" in performer || "givenName" in performer || "additionalName" in performer;
  return hasPersonProperties ? { "@type": SCHEMA_TYPES.PERSON, ...performer } : {
    "@type": SCHEMA_TYPES.PERFORMING_GROUP,
    ...performer
  };
}
function processOrganizer(organizer) {
  if (isString(organizer)) {
    return {
      "@type": SCHEMA_TYPES.ORGANIZATION,
      name: organizer
    };
  }
  if (hasType(organizer)) {
    return organizer;
  }
  const hasPersonProperties = "familyName" in organizer || "givenName" in organizer || "additionalName" in organizer;
  return hasPersonProperties ? { "@type": SCHEMA_TYPES.PERSON, ...organizer } : { "@type": SCHEMA_TYPES.ORGANIZATION, ...organizer };
}
function processOrganization(org) {
  if (isString(org)) {
    return {
      "@type": SCHEMA_TYPES.ORGANIZATION,
      name: org
    };
  }
  const processed = processSchemaType(
    org,
    SCHEMA_TYPES.ORGANIZATION
  );
  processOrganizationFields(processed);
  return processed;
}
function processOffer(offer) {
  return processSchemaType(offer, SCHEMA_TYPES.OFFER);
}
function processPublisher(publisher) {
  if (isString(publisher)) {
    return {
      "@type": SCHEMA_TYPES.ORGANIZATION,
      name: publisher
    };
  }
  if (hasType(publisher) && publisher["@type"] === SCHEMA_TYPES.ORGANIZATION) {
    const org2 = { ...publisher };
    processOrganizationFields(org2);
    return org2;
  }
  if (hasType(publisher)) {
    return publisher;
  }
  const org = {
    "@type": SCHEMA_TYPES.ORGANIZATION,
    ...publisher
  };
  processOrganizationFields(org);
  return org;
}
function processNutrition(nutrition) {
  return {
    "@type": SCHEMA_TYPES.NUTRITION_INFORMATION,
    ...nutrition
  };
}
function processAggregateRating(rating) {
  return processSchemaType(
    rating,
    SCHEMA_TYPES.AGGREGATE_RATING
  );
}
function processMainEntityOfPage(mainEntityOfPage) {
  if (isString(mainEntityOfPage)) {
    return mainEntityOfPage;
  }
  return processSchemaType(mainEntityOfPage, SCHEMA_TYPES.WEB_PAGE);
}
function processSimpleMonetaryAmount(amount) {
  if (!amount) return void 0;
  if (typeof amount === "number") {
    return {
      "@type": SCHEMA_TYPES.MONETARY_AMOUNT,
      value: amount,
      currency: "USD"
      // Default currency, should be overridden in component
    };
  }
  return processSchemaType(
    amount,
    SCHEMA_TYPES.MONETARY_AMOUNT
  );
}
function processReturnPolicySeasonalOverride(override) {
  return processSchemaType(
    override,
    SCHEMA_TYPES.MERCHANT_RETURN_POLICY_SEASONAL_OVERRIDE
  );
}
function processMerchantReturnPolicy(policy) {
  if (!policy) return policy;
  const processed = processSchemaType(
    policy,
    SCHEMA_TYPES.MERCHANT_RETURN_POLICY
  );
  if (processed.applicableCountry && !Array.isArray(processed.applicableCountry)) {
    processed.applicableCountry = [processed.applicableCountry];
  }
  if (processed.returnPolicyCountry && !Array.isArray(processed.returnPolicyCountry)) {
    processed.returnPolicyCountry = [processed.returnPolicyCountry];
  }
  if (processed.returnMethod && !Array.isArray(processed.returnMethod)) {
    processed.returnMethod = [processed.returnMethod];
  }
  if (processed.refundType && !Array.isArray(processed.refundType)) {
    processed.refundType = [processed.refundType];
  }
  if (processed.itemCondition && !Array.isArray(processed.itemCondition)) {
    processed.itemCondition = [processed.itemCondition];
  }
  if (processed.returnShippingFeesAmount) {
    processed.returnShippingFeesAmount = processSimpleMonetaryAmount(
      processed.returnShippingFeesAmount
    );
  }
  if (processed.customerRemorseReturnShippingFeesAmount) {
    processed.customerRemorseReturnShippingFeesAmount = processSimpleMonetaryAmount(
      processed.customerRemorseReturnShippingFeesAmount
    );
  }
  if (processed.itemDefectReturnShippingFeesAmount) {
    processed.itemDefectReturnShippingFeesAmount = processSimpleMonetaryAmount(
      processed.itemDefectReturnShippingFeesAmount
    );
  }
  if (processed.restockingFee && typeof processed.restockingFee === "object") {
    processed.restockingFee = processSimpleMonetaryAmount(
      processed.restockingFee
    );
  }
  if (processed.returnPolicySeasonalOverride) {
    if (Array.isArray(processed.returnPolicySeasonalOverride)) {
      processed.returnPolicySeasonalOverride = processed.returnPolicySeasonalOverride.map(
        processReturnPolicySeasonalOverride
      );
    } else {
      processed.returnPolicySeasonalOverride = processReturnPolicySeasonalOverride(
        processed.returnPolicySeasonalOverride
      );
    }
  }
  return processed;
}
function processTierRequirement(requirement) {
  if (!requirement) return requirement;
  if (isString(requirement)) {
    return requirement;
  }
  if (hasType(requirement)) {
    return requirement;
  }
  if ("priceCurrency" in requirement && "price" in requirement) {
    if ("billingDuration" in requirement || "billingIncrement" in requirement || "unitCode" in requirement) {
      return {
        "@type": SCHEMA_TYPES.UNIT_PRICE_SPECIFICATION,
        ...requirement
      };
    }
  }
  if ("value" in requirement && "currency" in requirement) {
    return {
      "@type": SCHEMA_TYPES.MONETARY_AMOUNT,
      ...requirement
    };
  }
  if ("name" in requirement) {
    return {
      "@type": SCHEMA_TYPES.CREDIT_CARD,
      ...requirement
    };
  }
  return requirement;
}
function processTierBenefit(benefit) {
  const normalizeBenefit = (b) => {
    if (b.startsWith("https://schema.org/")) {
      return b;
    }
    if (b === "TierBenefitLoyaltyPoints") {
      return "https://schema.org/TierBenefitLoyaltyPoints";
    }
    if (b === "TierBenefitLoyaltyPrice") {
      return "https://schema.org/TierBenefitLoyaltyPrice";
    }
    return b;
  };
  if (Array.isArray(benefit)) {
    return benefit.map(normalizeBenefit);
  }
  return normalizeBenefit(benefit);
}
function processMembershipPointsEarned(points) {
  if (typeof points === "number") {
    return {
      "@type": SCHEMA_TYPES.QUANTITATIVE_VALUE,
      value: points
    };
  }
  return processSchemaType(
    points,
    SCHEMA_TYPES.QUANTITATIVE_VALUE
  );
}
function processMemberProgramTier(tier) {
  const processed = processSchemaType(
    tier,
    SCHEMA_TYPES.MEMBER_PROGRAM_TIER
  );
  if (processed.hasTierBenefit) {
    processed.hasTierBenefit = processTierBenefit(processed.hasTierBenefit);
  }
  if (processed.hasTierRequirement) {
    processed.hasTierRequirement = processTierRequirement(
      processed.hasTierRequirement
    );
  }
  if (processed.membershipPointsEarned !== void 0) {
    processed.membershipPointsEarned = processMembershipPointsEarned(
      processed.membershipPointsEarned
    );
  }
  return processed;
}
function processMemberProgram(program) {
  const processed = processSchemaType(
    program,
    SCHEMA_TYPES.MEMBER_PROGRAM
  );
  if (processed.hasTiers) {
    if (Array.isArray(processed.hasTiers)) {
      processed.hasTiers = processed.hasTiers.map(processMemberProgramTier);
    } else {
      processed.hasTiers = processMemberProgramTier(processed.hasTiers);
    }
  }
  return processed;
}
function processVideo(video) {
  return processSchemaType(video, SCHEMA_TYPES.VIDEO_OBJECT);
}
function processBroadcastEvent(broadcast) {
  if (!broadcast) return broadcast;
  if (typeof broadcast === "object" && !("@type" in broadcast)) {
    return {
      "@type": "BroadcastEvent",
      ...broadcast
    };
  }
  return broadcast;
}
function processClip(clip) {
  if (!clip) return clip;
  if (typeof clip === "object" && !("@type" in clip)) {
    return {
      "@type": "Clip",
      ...clip
    };
  }
  return clip;
}
function processSeekToAction(action) {
  if (!action) return action;
  if (typeof action === "object" && !("@type" in action)) {
    return {
      "@type": "SeekToAction",
      ...action
    };
  }
  return action;
}
function processInstruction(instruction) {
  if (isString(instruction)) {
    return instruction;
  }
  if (hasType(instruction)) {
    if (instruction["@type"] === SCHEMA_TYPES.HOW_TO_SECTION && "itemListElement" in instruction) {
      return {
        ...instruction,
        itemListElement: instruction.itemListElement.map(
          (item) => processInstruction(item)
        )
      };
    }
    return instruction;
  }
  if ("itemListElement" in instruction) {
    return {
      "@type": SCHEMA_TYPES.HOW_TO_SECTION,
      ...instruction,
      itemListElement: instruction.itemListElement.map(
        (item) => processInstruction(item)
      )
    };
  }
  return {
    "@type": SCHEMA_TYPES.HOW_TO_STEP,
    ...instruction
  };
}
function processDirector(director) {
  return processSchemaType(
    director,
    SCHEMA_TYPES.PERSON,
    (str) => ({ name: str }),
    void 0
  );
}
function processCreator(creator) {
  return Array.isArray(creator) ? creator.map(processAuthor) : processAuthor(creator);
}
function processIdentifier(identifier) {
  if (isString(identifier)) {
    return identifier;
  }
  return processSchemaType(
    identifier,
    SCHEMA_TYPES.PROPERTY_VALUE
  );
}
function processSpatialCoverage(spatial) {
  if (isString(spatial)) {
    return spatial;
  }
  const processed = processSchemaType(
    spatial,
    SCHEMA_TYPES.PLACE
  );
  if (spatial.geo && typeof spatial.geo === "object" && !hasType(spatial.geo)) {
    if ("latitude" in spatial.geo && "longitude" in spatial.geo) {
      processed.geo = processSchemaType(
        spatial.geo,
        SCHEMA_TYPES.GEO_COORDINATES
      );
    } else if ("box" in spatial.geo || "circle" in spatial.geo || "line" in spatial.geo || "polygon" in spatial.geo) {
      processed.geo = processSchemaType(
        spatial.geo,
        SCHEMA_TYPES.GEO_SHAPE
      );
    }
  }
  return processed;
}
function processDataDownload(download) {
  return processSchemaType(download, SCHEMA_TYPES.DATA_DOWNLOAD);
}
function processLicense(license) {
  if (isString(license)) {
    return license;
  }
  return processSchemaType(license, SCHEMA_TYPES.CREATIVE_WORK);
}
function processDataCatalog(catalog) {
  return processSchemaType(catalog, SCHEMA_TYPES.DATA_CATALOG);
}
function processHiringOrganization(org) {
  if (isString(org)) {
    return {
      "@type": SCHEMA_TYPES.ORGANIZATION,
      name: org
    };
  }
  const processed = processSchemaType(
    org,
    SCHEMA_TYPES.ORGANIZATION
  );
  if (processed.logo && !isString(processed.logo)) {
    processed.logo = processImage(processed.logo);
  }
  return processed;
}
function processJobLocation(location) {
  if (isString(location)) {
    return {
      "@type": SCHEMA_TYPES.PLACE,
      address: {
        "@type": SCHEMA_TYPES.POSTAL_ADDRESS,
        streetAddress: location
      }
    };
  }
  const processed = processSchemaType(location, SCHEMA_TYPES.PLACE);
  if (processed.address && !isString(processed.address)) {
    processed.address = processAddress(processed.address);
  }
  return processed;
}
function processMonetaryAmount(amount) {
  const processed = processSchemaType(amount, "MonetaryAmount");
  processed.value = processSchemaType(
    amount.value,
    SCHEMA_TYPES.QUANTITATIVE_VALUE
  );
  return processed;
}
function processRating(rating) {
  return processSchemaType(rating, SCHEMA_TYPES.RATING);
}
function processJobPropertyValue(identifier) {
  return processSchemaType(
    identifier,
    SCHEMA_TYPES.PROPERTY_VALUE,
    (str) => ({ value: str }),
    void 0
  );
}
function processApplicantLocationRequirements(location) {
  if (hasType(location)) {
    return location;
  }
  const name = location.name;
  const statePatterns = [
    /\b[A-Z]{2}\b/,
    // Two-letter state codes
    /\bstate\b/i,
    // Contains "state"
    /,/,
    // Contains comma (often "City, State")
    /\b(AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY)\b/
    // US state codes
  ];
  const isState = statePatterns.some((pattern) => pattern.test(name));
  return {
    "@type": isState ? SCHEMA_TYPES.STATE : SCHEMA_TYPES.COUNTRY,
    ...location
  };
}
function processEducationRequirements(education) {
  if (isString(education)) {
    return education;
  }
  return processSchemaType(
    education,
    SCHEMA_TYPES.EDUCATIONAL_CREDENTIAL
  );
}
function processExperienceRequirements(experience) {
  if (isString(experience)) {
    return experience;
  }
  return processSchemaType(
    experience,
    SCHEMA_TYPES.OCCUPATIONAL_EXPERIENCE
  );
}
function processInteractionStatistic(statistic) {
  return processSchemaType(
    statistic,
    SCHEMA_TYPES.INTERACTION_COUNTER
  );
}
function processSharedContent(content) {
  if (isString(content)) {
    return {
      "@type": SCHEMA_TYPES.WEB_PAGE,
      url: content
    };
  }
  if (hasType(content)) {
    return content;
  }
  const hasVideoProperties = "uploadDate" in content && "thumbnailUrl" in content;
  const hasImageProperties = "url" in content && ("width" in content || "height" in content);
  if (hasVideoProperties) {
    return processSchemaType(content, SCHEMA_TYPES.VIDEO_OBJECT);
  }
  if (hasImageProperties) {
    return processSchemaType(content, SCHEMA_TYPES.IMAGE_OBJECT);
  }
  return processSchemaType(content, SCHEMA_TYPES.WEB_PAGE);
}
function processComment(comment) {
  const processed = processSchemaType(
    comment,
    SCHEMA_TYPES.COMMENT
  );
  if (comment.author) {
    processed.author = processAuthor(comment.author);
  }
  if (comment.image && !isString(comment.image)) {
    processed.image = processImage(comment.image);
  }
  if (comment.video) {
    processed.video = processVideo(comment.video);
  }
  if (comment.interactionStatistic) {
    processed.interactionStatistic = Array.isArray(comment.interactionStatistic) ? comment.interactionStatistic.map(processInteractionStatistic) : processInteractionStatistic(comment.interactionStatistic);
  }
  if (comment.sharedContent) {
    processed.sharedContent = processSharedContent(comment.sharedContent);
  }
  if (comment.comment) {
    processed.comment = comment.comment.map(processComment);
  }
  return processed;
}
function processIsPartOf(isPartOf) {
  if (isString(isPartOf)) {
    return isPartOf;
  }
  return processSchemaType(
    isPartOf,
    SCHEMA_TYPES.CREATIVE_WORK
  );
}
function processBrand(brand) {
  if ("@type" in brand) {
    return brand;
  }
  if ("logo" in brand || "address" in brand || "contactPoint" in brand) {
    const org = {
      "@type": SCHEMA_TYPES.ORGANIZATION,
      ...brand
    };
    processOrganizationFields(org);
    return org;
  }
  return processSchemaType(brand, SCHEMA_TYPES.BRAND);
}
function processBedDetails(bed) {
  return processSchemaType(bed, SCHEMA_TYPES.BED_DETAILS);
}
function processLocationFeatureSpecification(feature) {
  return processSchemaType(
    feature,
    SCHEMA_TYPES.LOCATION_FEATURE
  );
}
function processAccommodation(accommodation) {
  const processed = processSchemaType(
    accommodation,
    SCHEMA_TYPES.ACCOMMODATION
  );
  if (accommodation.bed) {
    processed.bed = Array.isArray(accommodation.bed) ? accommodation.bed.map(processBedDetails) : processBedDetails(accommodation.bed);
  }
  if (accommodation.occupancy) {
    processed.occupancy = processNumberOfEmployees(
      accommodation.occupancy
    );
  }
  if (accommodation.amenityFeature) {
    processed.amenityFeature = Array.isArray(accommodation.amenityFeature) ? accommodation.amenityFeature.map(processLocationFeatureSpecification) : processLocationFeatureSpecification(accommodation.amenityFeature);
  }
  if (accommodation.floorSize) {
    processed.floorSize = processNumberOfEmployees(
      accommodation.floorSize
    );
  }
  return processed;
}
function processProvider(provider) {
  return processSchemaType(
    provider,
    SCHEMA_TYPES.ORGANIZATION,
    (str) => ({ name: str }),
    void 0
  );
}
function processFunder(funder) {
  if (Array.isArray(funder)) {
    return funder.map(processFunderSingle);
  }
  return processFunderSingle(funder);
}
function processFunderSingle(funder) {
  if (isString(funder)) {
    return {
      "@type": SCHEMA_TYPES.ORGANIZATION,
      name: funder
    };
  }
  if (hasType(funder)) {
    return funder;
  }
  return {
    "@type": SCHEMA_TYPES.ORGANIZATION,
    ...funder
  };
}
function processScreenshot(screenshot) {
  return processImage(screenshot);
}
function processFeatureList(features) {
  return features;
}
function processClaimReviewRating(rating) {
  return processSchemaType(rating, SCHEMA_TYPES.RATING);
}
function processClaim(claim) {
  const processed = processSchemaType(claim, SCHEMA_TYPES.CLAIM);
  if (claim.author) {
    processed.author = processAuthor(claim.author);
  }
  if (claim.appearance) {
    if (Array.isArray(claim.appearance)) {
      processed.appearance = claim.appearance.map(processAppearance);
    } else {
      processed.appearance = processAppearance(claim.appearance);
    }
  }
  if (claim.firstAppearance) {
    processed.firstAppearance = processAppearance(claim.firstAppearance);
  }
  return processed;
}
function processAppearance(appearance) {
  if (isString(appearance)) {
    return appearance;
  }
  const processed = processSchemaType(
    appearance,
    SCHEMA_TYPES.CREATIVE_WORK
  );
  if (appearance.author) {
    processed.author = processAuthor(appearance.author);
  }
  if (appearance.publisher && !isString(appearance.publisher)) {
    processed.publisher = processPublisher(appearance.publisher);
  }
  return processed;
}
function processWebPageElement(element) {
  return processSchemaType(
    element,
    SCHEMA_TYPES.WEB_PAGE_ELEMENT
  );
}
function processProductOffer(offer) {
  const processed = processSchemaType(
    offer,
    SCHEMA_TYPES.OFFER
  );
  if (offer.seller) {
    processed.seller = processAuthor(offer.seller);
  }
  if (offer.priceSpecification) {
    if (Array.isArray(offer.priceSpecification)) {
      processed.priceSpecification = offer.priceSpecification.map(
        processPriceSpecification
      );
    } else {
      processed.priceSpecification = processPriceSpecification(
        offer.priceSpecification
      );
    }
  }
  if (offer.hasMerchantReturnPolicy) {
    if (Array.isArray(offer.hasMerchantReturnPolicy)) {
      processed.hasMerchantReturnPolicy = offer.hasMerchantReturnPolicy.map(
        processMerchantReturnPolicy
      );
    } else {
      processed.hasMerchantReturnPolicy = processMerchantReturnPolicy(
        offer.hasMerchantReturnPolicy
      );
    }
  }
  if (offer.shippingDetails) {
    if (Array.isArray(offer.shippingDetails)) {
      processed.shippingDetails = offer.shippingDetails.map(
        processOfferShippingDetails
      );
    } else {
      processed.shippingDetails = processOfferShippingDetails(
        offer.shippingDetails
      );
    }
  }
  return processed;
}
function processAggregateOffer(offer) {
  const processed = processSchemaType(
    offer,
    SCHEMA_TYPES.AGGREGATE_OFFER
  );
  if (offer.offers) {
    processed.offers = offer.offers.map(processProductOffer);
  }
  return processed;
}
function processPriceSpecification(spec) {
  if ("priceType" in spec || "validForMemberTier" in spec || "membershipPointsEarned" in spec || "referenceQuantity" in spec) {
    return processUnitPriceSpecification(
      spec
    );
  }
  return processSchemaType(
    spec,
    SCHEMA_TYPES.PRICE_SPECIFICATION
  );
}
function processUnitPriceSpecification(spec) {
  const processed = processSchemaType(
    spec,
    SCHEMA_TYPES.UNIT_PRICE_SPECIFICATION
  );
  if (spec.validForMemberTier) {
    if (Array.isArray(spec.validForMemberTier)) {
      processed.validForMemberTier = spec.validForMemberTier.map(
        processMemberProgramTier
      );
    } else {
      processed.validForMemberTier = processMemberProgramTier(
        spec.validForMemberTier
      );
    }
  }
  if (spec.referenceQuantity) {
    processed.referenceQuantity = processQuantitativeValue(
      spec.referenceQuantity
    );
  }
  return processed;
}
function processQuantitativeValue(value) {
  const processed = processSchemaType(
    value,
    SCHEMA_TYPES.QUANTITATIVE_VALUE
  );
  if (value.valueReference) {
    processed.valueReference = processQuantitativeValue(value.valueReference);
  }
  return processed;
}
function processProductItemList(list) {
  const processed = processSchemaType(
    list,
    SCHEMA_TYPES.ITEM_LIST
  );
  if (list.itemListElement) {
    processed.itemListElement = list.itemListElement.map((item, index) => {
      const processedItem = processSchemaType(
        item,
        SCHEMA_TYPES.LIST_ITEM
      );
      if (!processedItem.position) {
        processedItem.position = index + 1;
      }
      return processedItem;
    });
  }
  return processed;
}
function processProductReview(review) {
  const processed = processSchemaType(
    review,
    SCHEMA_TYPES.REVIEW
  );
  if (review.reviewRating) {
    processed.reviewRating = processSchemaType(
      review.reviewRating,
      SCHEMA_TYPES.RATING
    );
  }
  if (review.author) {
    processed.author = processAuthor(review.author);
  }
  if (review.positiveNotes) {
    processed.positiveNotes = processProductItemList(review.positiveNotes);
  }
  if (review.negativeNotes) {
    processed.negativeNotes = processProductItemList(review.negativeNotes);
  }
  return processed;
}
function processVariesBy(variesBy) {
  const processOne = (value) => {
    if (value.startsWith("https://schema.org/")) {
      return value;
    }
    return `https://schema.org/${value}`;
  };
  if (Array.isArray(variesBy)) {
    return variesBy.map(processOne);
  }
  return processOne(variesBy);
}
function processProductVariant(variant) {
  if ("url" in variant && Object.keys(variant).length <= 2) {
    return variant;
  }
  const product = variant;
  if ("@type" in product) {
    return product;
  }
  const processed = {
    "@type": SCHEMA_TYPES.PRODUCT,
    ...product
  };
  if (product.image) {
    processed.image = Array.isArray(product.image) ? product.image.map(processImage) : processImage(product.image);
  }
  if (product.brand) {
    if (typeof product.brand === "string") {
      processed.brand = {
        "@type": SCHEMA_TYPES.BRAND,
        name: product.brand
      };
    } else {
      processed.brand = processBrand(product.brand);
    }
  }
  if (product.offers) {
    if (Array.isArray(product.offers)) {
      processed.offers = product.offers.map((offer) => {
        if ("lowPrice" in offer && "priceCurrency" in offer) {
          return processAggregateOffer(
            offer
          );
        }
        return processProductOffer(
          offer
        );
      });
    } else if ("lowPrice" in product.offers && "priceCurrency" in product.offers) {
      processed.offers = processAggregateOffer(
        product.offers
      );
    } else {
      processed.offers = processProductOffer(
        product.offers
      );
    }
  }
  if (product.review) {
    processed.review = Array.isArray(product.review) ? product.review.map(processProductReview) : processProductReview(product.review);
  }
  if (product.aggregateRating) {
    processed.aggregateRating = processAggregateRating(product.aggregateRating);
  }
  if (product.manufacturer) {
    processed.manufacturer = processAuthor(product.manufacturer);
  }
  if (product.weight && typeof product.weight === "object" && !("@type" in product.weight)) {
    processed.weight = { "@type": "QuantitativeValue", ...product.weight };
  }
  if (product.width && typeof product.width === "object" && !("@type" in product.width)) {
    processed.width = { "@type": "QuantitativeValue", ...product.width };
  }
  if (product.height && typeof product.height === "object" && !("@type" in product.height)) {
    processed.height = { "@type": "QuantitativeValue", ...product.height };
  }
  if (product.depth && typeof product.depth === "object" && !("@type" in product.depth)) {
    processed.depth = { "@type": "QuantitativeValue", ...product.depth };
  }
  return processed;
}
function processCertification(cert) {
  const processed = processSchemaType(
    cert,
    SCHEMA_TYPES.CERTIFICATION
  );
  if (cert.issuedBy) {
    if (typeof cert.issuedBy === "object" && !("@type" in cert.issuedBy)) {
      processed.issuedBy = {
        "@type": SCHEMA_TYPES.ORGANIZATION,
        ...cert.issuedBy
      };
    } else {
      processed.issuedBy = cert.issuedBy;
    }
  }
  if (cert.certificationRating) {
    processed.certificationRating = processRating(cert.certificationRating);
  }
  return processed;
}
function processPeopleAudience(audience) {
  const processed = processSchemaType(
    audience,
    SCHEMA_TYPES.PEOPLE_AUDIENCE
  );
  if (audience.suggestedAge) {
    processed.suggestedAge = processQuantitativeValue(audience.suggestedAge);
  }
  return processed;
}
function processSizeSpecification(size) {
  if (typeof size === "string") {
    return size;
  }
  return processSchemaType(
    size,
    SCHEMA_TYPES.SIZE_SPECIFICATION
  );
}
function processThreeDModel(model) {
  const processed = processSchemaType(
    model,
    SCHEMA_TYPES.THREE_D_MODEL
  );
  if (model.encoding && !("@type" in model.encoding)) {
    processed.encoding = {
      "@type": "MediaObject",
      ...model.encoding
    };
  }
  return processed;
}
function processDefinedRegion(region) {
  return processSchemaType(region, SCHEMA_TYPES.DEFINED_REGION);
}
function processShippingDeliveryTime(time) {
  const processed = processSchemaType(
    time,
    SCHEMA_TYPES.SHIPPING_DELIVERY_TIME
  );
  if (time.handlingTime) {
    processed.handlingTime = processQuantitativeValue(time.handlingTime);
  }
  if (time.transitTime) {
    processed.transitTime = processQuantitativeValue(time.transitTime);
  }
  return processed;
}
function processOfferShippingDetails(details) {
  const processed = processSchemaType(
    details,
    SCHEMA_TYPES.OFFER_SHIPPING_DETAILS
  );
  if (details.shippingRate) {
    processed.shippingRate = processSimpleMonetaryAmount(details.shippingRate);
  }
  if (details.shippingDestination) {
    if (Array.isArray(details.shippingDestination)) {
      processed.shippingDestination = details.shippingDestination.map(processDefinedRegion);
    } else {
      processed.shippingDestination = processDefinedRegion(
        details.shippingDestination
      );
    }
  }
  if (details.deliveryTime) {
    processed.deliveryTime = processShippingDeliveryTime(details.deliveryTime);
  }
  return processed;
}
function processItemReviewed(itemReviewed, defaultType) {
  if (isString(itemReviewed)) {
    return { "@type": defaultType || "Thing", name: itemReviewed };
  }
  if (typeof itemReviewed === "object" && itemReviewed !== null && "@type" in itemReviewed) {
    return itemReviewed;
  }
  const candidate = {
    ...itemReviewed
  };
  const inferType = () => {
    if (defaultType) return defaultType;
    if ("brand" in candidate || "sku" in candidate) return "Product";
    if ("recipeIngredient" in candidate || "recipeInstructions" in candidate)
      return "Recipe";
    if ("servesCuisine" in candidate || "address" in candidate)
      return "LocalBusiness";
    if ("applicationCategory" in candidate || "operatingSystem" in candidate)
      return "SoftwareApplication";
    if ("director" in candidate || "actor" in candidate) return "Movie";
    if ("provider" in candidate) return "Course";
    return "Thing";
  };
  return { "@type": inferType(), ...candidate };
}
function processHowToDirection(direction) {
  const processed = processSchemaType(
    direction,
    SCHEMA_TYPES.HOW_TO_DIRECTION
  );
  if (direction.beforeMedia && !isString(direction.beforeMedia)) {
    processed.beforeMedia = processImage(direction.beforeMedia);
  }
  if (direction.afterMedia && !isString(direction.afterMedia)) {
    processed.afterMedia = processImage(direction.afterMedia);
  }
  if (direction.duringMedia && !isString(direction.duringMedia)) {
    processed.duringMedia = processImage(direction.duringMedia);
  }
  return processed;
}
function processHowToTip(tip) {
  return processSchemaType(tip, SCHEMA_TYPES.HOW_TO_TIP);
}
function processHowToStepItem(item) {
  if (hasType(item)) {
    if (item["@type"] === SCHEMA_TYPES.HOW_TO_DIRECTION) {
      return processHowToDirection(item);
    }
    return processHowToTip(item);
  }
  if ("beforeMedia" in item || "afterMedia" in item || "duringMedia" in item) {
    return processHowToDirection(item);
  }
  return processHowToDirection(item);
}
function processHowToStep(step) {
  if (isString(step)) {
    return step;
  }
  const processed = processSchemaType(
    step,
    SCHEMA_TYPES.HOW_TO_STEP
  );
  if (step.image && !isString(step.image)) {
    processed.image = processImage(step.image);
  }
  if (step.itemListElement) {
    processed.itemListElement = step.itemListElement.map(processHowToStepItem);
  }
  return processed;
}
function processHowToSection(section) {
  const processed = processSchemaType(
    section,
    SCHEMA_TYPES.HOW_TO_SECTION
  );
  if (section.itemListElement) {
    processed.itemListElement = section.itemListElement.map((item) => {
      const result = processHowToStep(item);
      return typeof result === "string" ? { "@type": "HowToStep", text: result } : result;
    });
  }
  return processed;
}
function processStep(step) {
  if (isString(step)) {
    return step;
  }
  if (hasType(step)) {
    if (step["@type"] === SCHEMA_TYPES.HOW_TO_SECTION) {
      return processHowToSection(step);
    }
    const result2 = processHowToStep(step);
    return typeof result2 === "string" ? { "@type": "HowToStep", text: result2 } : result2;
  }
  if ("itemListElement" in step && "name" in step) {
    return processHowToSection(step);
  }
  const result = processHowToStep(step);
  return typeof result === "string" ? { "@type": "HowToStep", text: result } : result;
}
function processHowToSupply(supply) {
  if (isString(supply)) {
    return {
      "@type": SCHEMA_TYPES.HOW_TO_SUPPLY,
      name: supply
    };
  }
  const processed = processSchemaType(
    supply,
    SCHEMA_TYPES.HOW_TO_SUPPLY
  );
  if (supply.image && !isString(supply.image)) {
    processed.image = processImage(supply.image);
  }
  if (supply.estimatedCost && !isString(supply.estimatedCost)) {
    processed.estimatedCost = processSimpleMonetaryAmount(supply.estimatedCost);
  }
  if (supply.requiredQuantity && typeof supply.requiredQuantity === "object") {
    processed.requiredQuantity = processQuantitativeValue(
      supply.requiredQuantity
    );
  }
  return processed;
}
function processHowToTool(tool) {
  if (isString(tool)) {
    return {
      "@type": SCHEMA_TYPES.HOW_TO_TOOL,
      name: tool
    };
  }
  const processed = processSchemaType(
    tool,
    SCHEMA_TYPES.HOW_TO_TOOL
  );
  if (tool.image && !isString(tool.image)) {
    processed.image = processImage(tool.image);
  }
  if (tool.requiredQuantity && typeof tool.requiredQuantity === "object") {
    processed.requiredQuantity = processQuantitativeValue(
      tool.requiredQuantity
    );
  }
  return processed;
}
function processEstimatedCost(cost) {
  if (isString(cost)) {
    return cost;
  }
  return processSimpleMonetaryAmount(cost);
}
function processHowToYield(yieldValue) {
  if (isString(yieldValue)) {
    return yieldValue;
  }
  return processQuantitativeValue(yieldValue);
}

// src/components/ArticleJsonLd.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
function ArticleJsonLd({
  type = "Article",
  scriptId,
  scriptKey,
  headline,
  url,
  author,
  datePublished,
  dateModified,
  image,
  publisher,
  description,
  isAccessibleForFree,
  mainEntityOfPage
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": type,
    headline,
    ...url && { url },
    ...author && {
      author: Array.isArray(author) ? author.map(processAuthor) : processAuthor(author)
    },
    ...datePublished && { datePublished },
    ...dateModified && { dateModified },
    // If dateModified is not provided but datePublished is, use datePublished
    ...!dateModified && datePublished && { dateModified: datePublished },
    ...image && {
      image: Array.isArray(image) ? image.map(processImage) : processImage(image)
    },
    ...publisher && { publisher: processPublisher(publisher) },
    ...description && { description },
    ...isAccessibleForFree !== void 0 && { isAccessibleForFree },
    ...mainEntityOfPage && {
      mainEntityOfPage: processMainEntityOfPage(mainEntityOfPage)
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || `article-jsonld-${type}`
    }
  );
}

// src/components/ClaimReviewJsonLd.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
function ClaimReviewJsonLd({
  scriptId,
  scriptKey,
  claimReviewed,
  reviewRating,
  url,
  author,
  itemReviewed
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": "ClaimReview",
    claimReviewed,
    reviewRating: processClaimReviewRating(reviewRating),
    url,
    ...author && { author: processAuthor(author) },
    ...itemReviewed && { itemReviewed: processClaim(itemReviewed) }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "claimreview-jsonld"
    }
  );
}

// src/components/CreativeWorkJsonLd.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
function CreativeWorkJsonLd({
  type = "CreativeWork",
  scriptId,
  scriptKey,
  headline,
  name,
  url,
  author,
  datePublished,
  dateModified,
  image,
  publisher,
  description,
  isAccessibleForFree,
  hasPart,
  mainEntityOfPage,
  // Additional properties for specific types
  text,
  // For Comment
  provider,
  // For Course
  itemReviewed,
  // For Review
  reviewRating
  // For Review
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": type,
    // Use headline if provided, otherwise use name
    ...headline && { headline },
    ...name && !headline && { name },
    ...url && { url },
    ...author && {
      author: Array.isArray(author) ? author.map(processAuthor) : processAuthor(author)
    },
    ...datePublished && { datePublished },
    ...dateModified && { dateModified },
    // If dateModified is not provided but datePublished is, use datePublished for certain types
    ...!dateModified && datePublished && ["Article", "NewsArticle", "BlogPosting"].includes(type) && {
      dateModified: datePublished
    },
    ...image && {
      image: Array.isArray(image) ? image.map(processImage) : processImage(image)
    },
    ...publisher && { publisher: processPublisher(publisher) },
    ...description && { description },
    ...isAccessibleForFree !== void 0 && { isAccessibleForFree },
    ...hasPart && {
      hasPart: Array.isArray(hasPart) ? hasPart.map(processWebPageElement) : processWebPageElement(hasPart)
    },
    ...mainEntityOfPage && {
      mainEntityOfPage: processMainEntityOfPage(mainEntityOfPage)
    },
    // Type-specific properties
    ...text && type === "Comment" && { text },
    ...provider && type === "Course" && { provider: processPublisher(provider) },
    ...itemReviewed && type === "Review" && { itemReviewed },
    ...reviewRating && type === "Review" && { reviewRating }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || `creativework-jsonld-${type.toLowerCase()}`
    }
  );
}

// src/components/RecipeJsonLd.tsx
var import_jsx_runtime5 = require("react/jsx-runtime");
function RecipeJsonLd({
  scriptId,
  scriptKey,
  name,
  image,
  description,
  author,
  datePublished,
  prepTime,
  cookTime,
  totalTime,
  recipeYield,
  recipeCategory,
  recipeCuisine,
  nutrition,
  recipeIngredient,
  recipeInstructions,
  aggregateRating,
  video,
  keywords,
  url
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": "Recipe",
    name,
    image: Array.isArray(image) ? image.map(processImage) : processImage(image),
    ...description && { description },
    ...author && { author: processAuthor(author) },
    ...datePublished && { datePublished },
    ...prepTime && { prepTime },
    ...cookTime && { cookTime },
    ...totalTime && { totalTime },
    ...recipeYield !== void 0 && { recipeYield },
    ...recipeCategory && { recipeCategory },
    ...recipeCuisine && { recipeCuisine },
    ...nutrition && { nutrition: processNutrition(nutrition) },
    ...recipeIngredient && { recipeIngredient },
    ...recipeInstructions && {
      recipeInstructions: Array.isArray(recipeInstructions) ? recipeInstructions.map(processInstruction) : processInstruction(recipeInstructions)
    },
    ...aggregateRating && {
      aggregateRating: processAggregateRating(aggregateRating)
    },
    ...video && { video: processVideo(video) },
    ...keywords && { keywords },
    ...url && { url }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "recipe-jsonld"
    }
  );
}

// src/components/HowToJsonLd.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
function HowToJsonLd({
  scriptId,
  scriptKey,
  name,
  description,
  image,
  estimatedCost,
  performTime,
  prepTime,
  totalTime,
  step,
  supply,
  tool,
  yield: yieldValue,
  video
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": "HowTo",
    name,
    ...description && { description },
    ...image && {
      image: Array.isArray(image) ? image.map(processImage) : processImage(image)
    },
    ...estimatedCost && {
      estimatedCost: processEstimatedCost(estimatedCost)
    },
    ...performTime && { performTime },
    ...prepTime && { prepTime },
    ...totalTime && { totalTime },
    ...step && {
      step: Array.isArray(step) ? step.map(processStep) : processStep(step)
    },
    ...supply && {
      supply: Array.isArray(supply) ? supply.map(processHowToSupply) : processHowToSupply(supply)
    },
    ...tool && {
      tool: Array.isArray(tool) ? tool.map(processHowToTool) : processHowToTool(tool)
    },
    ...yieldValue && { yield: processHowToYield(yieldValue) },
    ...video && { video: processVideo(video) }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "howto-jsonld"
    }
  );
}

// src/components/OrganizationJsonLd.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
function OrganizationJsonLd(props) {
  const {
    type = "Organization",
    scriptId,
    scriptKey,
    name,
    url,
    logo,
    description,
    sameAs,
    address,
    contactPoint,
    telephone,
    email,
    alternateName,
    foundingDate,
    legalName,
    taxID,
    vatID,
    duns,
    leiCode,
    naics,
    globalLocationNumber,
    iso6523Code,
    numberOfEmployees,
    review,
    aggregateRating
  } = props;
  const data = {
    "@context": "https://schema.org",
    "@type": type,
    ...name && { name },
    ...url && { url },
    ...logo && { logo: processLogo(logo) },
    ...description && { description },
    ...sameAs && {
      sameAs: Array.isArray(sameAs) ? sameAs : [sameAs]
    },
    ...address && {
      address: Array.isArray(address) ? address.map(processAddress) : processAddress(address)
    },
    ...contactPoint && {
      contactPoint: Array.isArray(contactPoint) ? contactPoint.map(processContactPoint) : processContactPoint(contactPoint)
    },
    ...telephone && { telephone },
    ...email && { email },
    ...alternateName && { alternateName },
    ...foundingDate && { foundingDate },
    ...legalName && { legalName },
    ...taxID && { taxID },
    ...vatID && { vatID },
    ...duns && { duns },
    ...leiCode && { leiCode },
    ...naics && { naics },
    ...globalLocationNumber && { globalLocationNumber },
    ...iso6523Code && { iso6523Code },
    ...numberOfEmployees && {
      numberOfEmployees: processNumberOfEmployees(numberOfEmployees)
    },
    ...review && {
      review: Array.isArray(review) ? review.map(processReview) : processReview(review)
    },
    ...aggregateRating && {
      aggregateRating: processAggregateRating(aggregateRating)
    },
    ...type === "OnlineStore" && "hasMerchantReturnPolicy" in props && props.hasMerchantReturnPolicy && {
      hasMerchantReturnPolicy: Array.isArray(props.hasMerchantReturnPolicy) ? props.hasMerchantReturnPolicy.map(processMerchantReturnPolicy) : processMerchantReturnPolicy(props.hasMerchantReturnPolicy)
    },
    ...type === "OnlineStore" && "hasMemberProgram" in props && props.hasMemberProgram && {
      hasMemberProgram: Array.isArray(props.hasMemberProgram) ? props.hasMemberProgram.map(processMemberProgram) : processMemberProgram(props.hasMemberProgram)
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || `organization-jsonld-${type}`
    }
  );
}

// src/components/LocalBusinessJsonLd.tsx
var import_jsx_runtime8 = require("react/jsx-runtime");
function processDepartment(department) {
  return {
    "@type": department.type || "LocalBusiness",
    ...department.name && { name: department.name },
    ...department.address && {
      address: Array.isArray(department.address) ? department.address.map(processAddress) : processAddress(department.address)
    },
    ...department.url && { url: department.url },
    ...department.telephone && { telephone: department.telephone },
    ...department.image && {
      image: Array.isArray(department.image) ? department.image.map(processImage) : processImage(department.image)
    },
    ...department.priceRange && { priceRange: department.priceRange },
    ...department.geo && { geo: processGeo(department.geo) },
    ...department.openingHoursSpecification && {
      openingHoursSpecification: Array.isArray(
        department.openingHoursSpecification
      ) ? department.openingHoursSpecification.map(processOpeningHours) : processOpeningHours(department.openingHoursSpecification)
    },
    ...department.review && {
      review: Array.isArray(department.review) ? department.review.map(processReview) : processReview(department.review)
    },
    ...department.aggregateRating && {
      aggregateRating: processAggregateRating(department.aggregateRating)
    },
    ...department.menu && { menu: department.menu },
    ...department.servesCuisine && {
      servesCuisine: Array.isArray(department.servesCuisine) ? department.servesCuisine : [department.servesCuisine]
    },
    ...department.sameAs && {
      sameAs: Array.isArray(department.sameAs) ? department.sameAs : [department.sameAs]
    },
    ...department.branchOf && { branchOf: department.branchOf },
    ...department.currenciesAccepted && {
      currenciesAccepted: department.currenciesAccepted
    },
    ...department.paymentAccepted && {
      paymentAccepted: department.paymentAccepted
    },
    ...department.areaServed && {
      areaServed: Array.isArray(department.areaServed) ? department.areaServed : [department.areaServed]
    },
    ...department.email && { email: department.email },
    ...department.faxNumber && { faxNumber: department.faxNumber },
    ...department.slogan && { slogan: department.slogan },
    ...department.description && { description: department.description },
    ...department.publicAccess !== void 0 && {
      publicAccess: department.publicAccess
    },
    ...department.smokingAllowed !== void 0 && {
      smokingAllowed: department.smokingAllowed
    },
    ...department.isAccessibleForFree !== void 0 && {
      isAccessibleForFree: department.isAccessibleForFree
    }
  };
}
function LocalBusinessJsonLd({
  type = "LocalBusiness",
  scriptId,
  scriptKey,
  name,
  address,
  url,
  telephone,
  image,
  priceRange,
  geo,
  openingHoursSpecification,
  review,
  aggregateRating,
  department,
  menu,
  servesCuisine,
  sameAs,
  branchOf,
  currenciesAccepted,
  paymentAccepted,
  areaServed,
  email,
  faxNumber,
  slogan,
  description,
  publicAccess,
  smokingAllowed,
  isAccessibleForFree
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": type,
    name,
    address: Array.isArray(address) ? address.map(processAddress) : processAddress(address),
    ...url && { url },
    ...telephone && { telephone },
    ...image && {
      image: Array.isArray(image) ? image.map(processImage) : processImage(image)
    },
    ...priceRange && { priceRange },
    ...geo && { geo: processGeo(geo) },
    ...openingHoursSpecification && {
      openingHoursSpecification: Array.isArray(openingHoursSpecification) ? openingHoursSpecification.map(processOpeningHours) : processOpeningHours(openingHoursSpecification)
    },
    ...review && {
      review: Array.isArray(review) ? review.map(processReview) : processReview(review)
    },
    ...aggregateRating && {
      aggregateRating: processAggregateRating(aggregateRating)
    },
    ...department && {
      department: Array.isArray(department) ? department.map(processDepartment) : processDepartment(department)
    },
    ...menu && { menu },
    ...servesCuisine && {
      servesCuisine: Array.isArray(servesCuisine) ? servesCuisine : [servesCuisine]
    },
    ...sameAs && {
      sameAs: Array.isArray(sameAs) ? sameAs : [sameAs]
    },
    ...branchOf && { branchOf },
    ...currenciesAccepted && { currenciesAccepted },
    ...paymentAccepted && { paymentAccepted },
    ...areaServed && {
      areaServed: Array.isArray(areaServed) ? areaServed : [areaServed]
    },
    ...email && { email },
    ...faxNumber && { faxNumber },
    ...slogan && { slogan },
    ...description && { description },
    ...publicAccess !== void 0 && { publicAccess },
    ...smokingAllowed !== void 0 && { smokingAllowed },
    ...isAccessibleForFree !== void 0 && { isAccessibleForFree }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || `localbusiness-jsonld-${Array.isArray(type) ? type.join("-") : type}`
    }
  );
}

// src/components/MerchantReturnPolicyJsonLd.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
function MerchantReturnPolicyJsonLd({
  scriptId,
  scriptKey,
  applicableCountry,
  returnPolicyCountry,
  returnPolicyCategory,
  merchantReturnDays,
  returnMethod,
  returnFees,
  returnShippingFeesAmount,
  refundType,
  restockingFee,
  returnLabelSource,
  itemCondition,
  customerRemorseReturnFees,
  customerRemorseReturnShippingFeesAmount,
  customerRemorseReturnLabelSource,
  itemDefectReturnFees,
  itemDefectReturnShippingFeesAmount,
  itemDefectReturnLabelSource,
  returnPolicySeasonalOverride,
  merchantReturnLink
}) {
  const returnPolicy = {
    "@type": "MerchantReturnPolicy",
    // Option B: Simple link to policy
    ...merchantReturnLink && { merchantReturnLink },
    // Option A: Detailed properties
    ...applicableCountry && {
      applicableCountry: Array.isArray(applicableCountry) ? applicableCountry : [applicableCountry]
    },
    ...returnPolicyCountry && {
      returnPolicyCountry: Array.isArray(returnPolicyCountry) ? returnPolicyCountry : [returnPolicyCountry]
    },
    ...returnPolicyCategory && { returnPolicyCategory },
    ...merchantReturnDays !== void 0 && { merchantReturnDays },
    ...returnMethod && {
      returnMethod: Array.isArray(returnMethod) ? returnMethod : [returnMethod]
    },
    ...returnFees && { returnFees },
    ...returnShippingFeesAmount && {
      returnShippingFeesAmount: processSimpleMonetaryAmount(
        returnShippingFeesAmount
      )
    },
    ...refundType && {
      refundType: Array.isArray(refundType) ? refundType : [refundType]
    },
    ...restockingFee !== void 0 && {
      restockingFee: typeof restockingFee === "number" ? restockingFee : processSimpleMonetaryAmount(restockingFee)
    },
    ...returnLabelSource && { returnLabelSource },
    ...itemCondition && {
      itemCondition: Array.isArray(itemCondition) ? itemCondition : [itemCondition]
    },
    // Customer remorse specific properties
    ...customerRemorseReturnFees && { customerRemorseReturnFees },
    ...customerRemorseReturnShippingFeesAmount && {
      customerRemorseReturnShippingFeesAmount: processSimpleMonetaryAmount(
        customerRemorseReturnShippingFeesAmount
      )
    },
    ...customerRemorseReturnLabelSource && {
      customerRemorseReturnLabelSource
    },
    // Item defect specific properties
    ...itemDefectReturnFees && { itemDefectReturnFees },
    ...itemDefectReturnShippingFeesAmount && {
      itemDefectReturnShippingFeesAmount: processSimpleMonetaryAmount(
        itemDefectReturnShippingFeesAmount
      )
    },
    ...itemDefectReturnLabelSource && { itemDefectReturnLabelSource },
    // Seasonal override
    ...returnPolicySeasonalOverride && {
      returnPolicySeasonalOverride: Array.isArray(returnPolicySeasonalOverride) ? returnPolicySeasonalOverride.map(processReturnPolicySeasonalOverride) : processReturnPolicySeasonalOverride(returnPolicySeasonalOverride)
    }
  };
  const processedPolicy = processMerchantReturnPolicy(returnPolicy);
  const data = {
    "@context": "https://schema.org",
    ...processedPolicy
  };
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "merchant-return-policy-jsonld"
    }
  );
}

// src/components/MovieCarouselJsonLd.tsx
var import_jsx_runtime10 = require("react/jsx-runtime");
function processSummaryItem(item, index) {
  if (typeof item === "string") {
    return {
      "@type": "ListItem",
      position: index + 1,
      url: item
    };
  }
  return {
    "@type": "ListItem",
    position: item.position ?? index + 1,
    url: item.url
  };
}
function processMovieItem(movie, index) {
  const processedMovie = {
    "@type": "Movie",
    name: movie.name,
    image: Array.isArray(movie.image) ? movie.image.map(processImage) : processImage(movie.image),
    ...movie.url && { url: movie.url },
    ...movie.dateCreated && { dateCreated: movie.dateCreated },
    ...movie.director && { director: processDirector(movie.director) },
    ...movie.review && { review: processReview(movie.review) },
    ...movie.aggregateRating && {
      aggregateRating: processAggregateRating(movie.aggregateRating)
    }
  };
  return {
    "@type": "ListItem",
    position: index + 1,
    item: processedMovie
  };
}
function MovieCarouselJsonLd(props) {
  const { scriptId, scriptKey } = props;
  const isSummaryPage = "urls" in props;
  let itemListElement;
  if (isSummaryPage) {
    itemListElement = props.urls.map(
      (url, index) => processSummaryItem(url, index)
    );
  } else {
    itemListElement = props.movies.map(
      (movie, index) => processMovieItem(movie, index)
    );
  }
  const data = {
    "@context": "https://schema.org",
    "@type": "ItemList",
    itemListElement
  };
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "movie-carousel-jsonld"
    }
  );
}

// src/components/BreadcrumbJsonLd.tsx
var import_jsx_runtime11 = require("react/jsx-runtime");
function BreadcrumbJsonLd(props) {
  const { scriptId, scriptKey } = props;
  const hasMultipleTrails = "multipleTrails" in props;
  if (hasMultipleTrails) {
    const data = props.multipleTrails.map((trail) => ({
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: trail.map(
        (item, index) => processBreadcrumbItem(item, index + 1)
      )
    }));
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      JsonLdScript,
      {
        data,
        id: scriptId,
        scriptKey: scriptKey || "breadcrumb-jsonld-multiple"
      }
    );
  } else {
    const data = {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: props.items.map(
        (item, index) => processBreadcrumbItem(item, index + 1)
      )
    };
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      JsonLdScript,
      {
        data,
        id: scriptId,
        scriptKey: scriptKey || "breadcrumb-jsonld"
      }
    );
  }
}

// src/components/CarouselJsonLd.tsx
var import_jsx_runtime12 = require("react/jsx-runtime");
function processSummaryItem2(item, index) {
  if (typeof item === "string") {
    return {
      "@type": "ListItem",
      position: index + 1,
      url: item
    };
  }
  return {
    "@type": "ListItem",
    position: item.position ?? index + 1,
    url: item.url
  };
}
function processCourseItem(course, index) {
  const processedCourse = {
    "@type": "Course",
    name: course.name,
    description: course.description,
    ...course.url && { url: course.url },
    ...course.provider && { provider: processProvider(course.provider) }
  };
  return {
    "@type": "ListItem",
    position: index + 1,
    item: processedCourse
  };
}
function processMovieItem2(movie, index) {
  const processedMovie = {
    "@type": "Movie",
    name: movie.name,
    image: Array.isArray(movie.image) ? movie.image.map(processImage) : processImage(movie.image),
    ...movie.url && { url: movie.url },
    ...movie.dateCreated && { dateCreated: movie.dateCreated },
    ...movie.director && { director: processDirector(movie.director) },
    ...movie.review && { review: processReview(movie.review) },
    ...movie.aggregateRating && {
      aggregateRating: processAggregateRating(movie.aggregateRating)
    }
  };
  return {
    "@type": "ListItem",
    position: index + 1,
    item: processedMovie
  };
}
function processRecipeItem(recipe, index) {
  const processedRecipe = {
    "@type": "Recipe",
    name: recipe.name,
    image: Array.isArray(recipe.image) ? recipe.image.map(processImage) : processImage(recipe.image),
    ...recipe.description && { description: recipe.description },
    ...recipe.author && {
      author: typeof recipe.author === "string" ? { "@type": "Person", name: recipe.author } : recipe.author
    },
    ...recipe.datePublished && { datePublished: recipe.datePublished },
    ...recipe.prepTime && { prepTime: recipe.prepTime },
    ...recipe.cookTime && { cookTime: recipe.cookTime },
    ...recipe.totalTime && { totalTime: recipe.totalTime },
    ...recipe.recipeYield && { recipeYield: recipe.recipeYield },
    ...recipe.recipeCategory && { recipeCategory: recipe.recipeCategory },
    ...recipe.recipeCuisine && { recipeCuisine: recipe.recipeCuisine },
    ...recipe.nutrition && { nutrition: processNutrition(recipe.nutrition) },
    ...recipe.recipeIngredient && {
      recipeIngredient: recipe.recipeIngredient
    },
    ...recipe.recipeInstructions && {
      recipeInstructions: Array.isArray(recipe.recipeInstructions) ? recipe.recipeInstructions.map(processInstruction) : processInstruction(recipe.recipeInstructions)
    },
    ...recipe.aggregateRating && {
      aggregateRating: processAggregateRating(recipe.aggregateRating)
    },
    ...recipe.video && { video: processVideo(recipe.video) },
    ...recipe.keywords && { keywords: recipe.keywords },
    ...recipe.url && { url: recipe.url }
  };
  return {
    "@type": "ListItem",
    position: index + 1,
    item: processedRecipe
  };
}
function processRestaurantItem(restaurant, index) {
  const address = restaurant.address ? Array.isArray(restaurant.address) ? restaurant.address.map(
    (addr) => typeof addr === "string" ? addr : processAddress(addr)
  ) : typeof restaurant.address === "string" ? restaurant.address : processAddress(restaurant.address) : "";
  const processedRestaurant = {
    "@type": "Restaurant",
    name: restaurant.name,
    address,
    ...restaurant.url && { url: restaurant.url },
    ...restaurant.telephone && { telephone: restaurant.telephone },
    ...restaurant.image && {
      image: Array.isArray(restaurant.image) ? restaurant.image.map(processImage) : processImage(restaurant.image)
    },
    ...restaurant.priceRange && { priceRange: restaurant.priceRange },
    ...restaurant.geo && { geo: processGeo(restaurant.geo) },
    ...restaurant.openingHoursSpecification && {
      openingHoursSpecification: Array.isArray(
        restaurant.openingHoursSpecification
      ) ? restaurant.openingHoursSpecification.map(processOpeningHours) : processOpeningHours(restaurant.openingHoursSpecification)
    },
    ...restaurant.review && {
      review: Array.isArray(restaurant.review) ? restaurant.review.map(processReview) : processReview(restaurant.review)
    },
    ...restaurant.aggregateRating && {
      aggregateRating: processAggregateRating(restaurant.aggregateRating)
    },
    ...restaurant.menu && { menu: restaurant.menu },
    ...restaurant.servesCuisine && {
      servesCuisine: restaurant.servesCuisine
    },
    ...restaurant.sameAs && { sameAs: restaurant.sameAs }
  };
  return {
    "@type": "ListItem",
    position: index + 1,
    item: processedRestaurant
  };
}
function CarouselJsonLd(props) {
  const { scriptId, scriptKey } = props;
  let itemListElement;
  if ("urls" in props) {
    itemListElement = props.urls.map(
      (url, index) => processSummaryItem2(url, index)
    );
  } else {
    switch (props.contentType) {
      case "Course":
        itemListElement = props.items.map(
          (item, index) => processCourseItem(item, index)
        );
        break;
      case "Movie":
        itemListElement = props.items.map(
          (item, index) => processMovieItem2(item, index)
        );
        break;
      case "Recipe":
        itemListElement = props.items.map(
          (item, index) => processRecipeItem(item, index)
        );
        break;
      case "Restaurant":
        itemListElement = props.items.map(
          (item, index) => processRestaurantItem(item, index)
        );
        break;
      default:
        itemListElement = [];
    }
  }
  const data = {
    "@context": "https://schema.org",
    "@type": "ItemList",
    itemListElement
  };
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "carousel-jsonld"
    }
  );
}

// src/components/CourseJsonLd.tsx
var import_jsx_runtime13 = require("react/jsx-runtime");
function processSummaryItem3(item, index) {
  if (typeof item === "string") {
    return {
      "@type": "ListItem",
      position: index + 1,
      url: item
    };
  }
  return {
    "@type": "ListItem",
    position: item.position ?? index + 1,
    url: item.url
  };
}
function processCourseItem2(course, index) {
  const processedCourse = {
    "@type": "Course",
    name: course.name,
    description: course.description,
    ...course.url && { url: course.url },
    ...course.provider && { provider: processProvider(course.provider) }
  };
  return {
    "@type": "ListItem",
    position: index + 1,
    item: processedCourse
  };
}
function CourseJsonLd(props) {
  const { scriptId, scriptKey } = props;
  if (!("type" in props) || props.type === "single") {
    const data2 = {
      "@context": "https://schema.org",
      "@type": "Course",
      name: props.name,
      description: props.description,
      ...props.url && { url: props.url },
      ...props.provider && { provider: processProvider(props.provider) }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
      JsonLdScript,
      {
        data: data2,
        id: scriptId,
        scriptKey: scriptKey || "course-jsonld"
      }
    );
  }
  let itemListElement;
  if ("urls" in props && props.type === "list") {
    itemListElement = props.urls.map(
      (url, index) => processSummaryItem3(url, index)
    );
  } else if ("courses" in props && props.type === "list") {
    itemListElement = props.courses.map(
      (course, index) => processCourseItem2(course, index)
    );
  } else {
    itemListElement = [];
  }
  const data = {
    "@context": "https://schema.org",
    "@type": "ItemList",
    itemListElement
  };
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "course-list-jsonld"
    }
  );
}

// src/components/EventJsonLd.tsx
var import_jsx_runtime14 = require("react/jsx-runtime");
function EventJsonLd({
  scriptId,
  scriptKey,
  name,
  startDate,
  location,
  endDate,
  description,
  eventStatus,
  image,
  offers,
  performer,
  organizer,
  previousStartDate,
  url
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": "Event",
    name,
    startDate,
    location: processPlace(location),
    ...endDate && { endDate },
    ...description && { description },
    ...eventStatus && { eventStatus },
    ...image && {
      image: Array.isArray(image) ? image.map(processImage) : processImage(image)
    },
    ...offers && {
      offers: Array.isArray(offers) ? offers.map(processOffer) : processOffer(offers)
    },
    ...performer && {
      performer: Array.isArray(performer) ? performer.map(processPerformer) : processPerformer(performer)
    },
    ...organizer && {
      organizer: processOrganizer(organizer)
    },
    ...previousStartDate && { previousStartDate },
    ...url && { url }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "event-jsonld"
    }
  );
}

// src/components/FAQJsonLd.tsx
var import_jsx_runtime15 = require("react/jsx-runtime");
function processQuestion(input) {
  if (typeof input === "string") {
    return {
      "@type": "Question",
      name: input,
      acceptedAnswer: {
        "@type": "Answer",
        text: ""
      }
    };
  }
  if ("question" in input && "answer" in input) {
    return {
      "@type": "Question",
      name: input.question,
      acceptedAnswer: {
        "@type": "Answer",
        text: input.answer
      }
    };
  }
  if ("name" in input) {
    const acceptedAnswer = typeof input.acceptedAnswer === "string" ? {
      "@type": "Answer",
      text: input.acceptedAnswer
    } : input.acceptedAnswer;
    return {
      "@type": "Question",
      name: input.name,
      acceptedAnswer
    };
  }
  return {
    "@type": "Question",
    name: "",
    acceptedAnswer: {
      "@type": "Answer",
      text: ""
    }
  };
}
function FAQJsonLd({
  questions,
  scriptId,
  scriptKey
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    mainEntity: questions.map(processQuestion)
  };
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "faq-jsonld"
    }
  );
}

// src/components/ImageJsonLd.tsx
var import_jsx_runtime16 = require("react/jsx-runtime");
function ImageJsonLd({
  scriptId,
  scriptKey,
  ...props
}) {
  const processImage2 = (image) => {
    const hasRequiredMetadata = image.creator || image.creditText || image.copyrightNotice || image.license;
    if (!image.contentUrl || !hasRequiredMetadata) {
      console.warn(
        "ImageJsonLd: contentUrl and at least one of creator, creditText, copyrightNotice, or license is required"
      );
    }
    return {
      "@type": "ImageObject",
      contentUrl: image.contentUrl,
      ...image.creator && {
        creator: Array.isArray(image.creator) ? image.creator.map(processAuthor) : processAuthor(image.creator)
      },
      ...image.creditText && { creditText: image.creditText },
      ...image.copyrightNotice && { copyrightNotice: image.copyrightNotice },
      ...image.license && { license: image.license },
      ...image.acquireLicensePage && {
        acquireLicensePage: image.acquireLicensePage
      }
    };
  };
  const hasMultipleImages = "images" in props && Array.isArray(props.images);
  const data = hasMultipleImages ? props.images.map(processImage2) : processImage2(props);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    JsonLdScript,
    {
      data: {
        "@context": "https://schema.org",
        ...Array.isArray(data) ? {} : data,
        ...Array.isArray(data) && { "@graph": data }
      },
      id: scriptId,
      scriptKey: scriptKey || "image-jsonld"
    }
  );
}

// src/components/QuizJsonLd.tsx
var import_jsx_runtime17 = require("react/jsx-runtime");
function processQuestion2(input) {
  if (typeof input === "string") {
    return {
      "@type": "Question",
      eduQuestionType: "Flashcard",
      text: input,
      acceptedAnswer: {
        "@type": "Answer",
        text: input
      }
    };
  }
  if ("question" in input && "answer" in input) {
    return {
      "@type": "Question",
      eduQuestionType: "Flashcard",
      text: input.question,
      acceptedAnswer: {
        "@type": "Answer",
        text: input.answer
      }
    };
  }
  if ("text" in input) {
    const acceptedAnswer = typeof input.acceptedAnswer === "string" ? {
      "@type": "Answer",
      text: input.acceptedAnswer
    } : input.acceptedAnswer;
    return {
      "@type": "Question",
      eduQuestionType: "Flashcard",
      text: input.text,
      acceptedAnswer
    };
  }
  return {
    "@type": "Question",
    eduQuestionType: "Flashcard",
    text: "",
    acceptedAnswer: {
      "@type": "Answer",
      text: ""
    }
  };
}
function processAbout(about) {
  if (typeof about === "string") {
    return {
      "@type": "Thing",
      name: about
    };
  }
  return {
    "@type": "Thing",
    ...about
  };
}
function processEducationalAlignment(alignment) {
  return {
    "@type": "AlignmentObject",
    alignmentType: alignment.type,
    targetName: alignment.name
  };
}
function QuizJsonLd({
  questions,
  about,
  educationalAlignment,
  scriptId,
  scriptKey
}) {
  const data = {
    "@context": "https://schema.org/",
    "@type": "Quiz",
    ...about && {
      about: processAbout(about)
    },
    ...educationalAlignment && {
      educationalAlignment: educationalAlignment.map(
        processEducationalAlignment
      )
    },
    hasPart: questions.map(processQuestion2)
  };
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "quiz-jsonld"
    }
  );
}

// src/components/DatasetJsonLd.tsx
var import_jsx_runtime18 = require("react/jsx-runtime");
function DatasetJsonLd({
  scriptId,
  scriptKey,
  name,
  description,
  url,
  sameAs,
  identifier,
  keywords,
  license,
  isAccessibleForFree,
  hasPart,
  isPartOf,
  creator,
  funder,
  includedInDataCatalog,
  distribution,
  temporalCoverage,
  spatialCoverage,
  alternateName,
  citation,
  measurementTechnique,
  variableMeasured,
  version
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": "Dataset",
    name,
    description,
    ...url && { url },
    ...sameAs && { sameAs },
    ...identifier && {
      identifier: Array.isArray(identifier) ? identifier.map(processIdentifier) : processIdentifier(identifier)
    },
    ...keywords && { keywords },
    ...license && { license: processLicense(license) },
    ...isAccessibleForFree !== void 0 && { isAccessibleForFree },
    ...hasPart && { hasPart },
    ...isPartOf && { isPartOf },
    ...creator && { creator: processCreator(creator) },
    ...funder && { funder: processFunder(funder) },
    ...includedInDataCatalog && {
      includedInDataCatalog: processDataCatalog(includedInDataCatalog)
    },
    ...distribution && {
      distribution: Array.isArray(distribution) ? distribution.map(processDataDownload) : processDataDownload(distribution)
    },
    ...temporalCoverage && { temporalCoverage },
    ...spatialCoverage && {
      spatialCoverage: processSpatialCoverage(spatialCoverage)
    },
    ...alternateName && { alternateName },
    ...citation && { citation },
    ...measurementTechnique && { measurementTechnique },
    ...variableMeasured && {
      variableMeasured: Array.isArray(variableMeasured) ? variableMeasured.map(
        (v) => typeof v === "string" ? v : processIdentifier(v)
      ) : typeof variableMeasured === "string" ? variableMeasured : processIdentifier(variableMeasured)
    },
    ...version && { version }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "dataset-jsonld"
    }
  );
}

// src/components/JobPostingJsonLd.tsx
var import_jsx_runtime19 = require("react/jsx-runtime");
function JobPostingJsonLd({
  scriptId,
  scriptKey,
  title,
  description,
  datePosted,
  hiringOrganization,
  jobLocation,
  url,
  validThrough,
  employmentType,
  identifier,
  baseSalary,
  applicantLocationRequirements,
  jobLocationType,
  directApply,
  educationRequirements,
  experienceRequirements,
  experienceInPlaceOfEducation
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": "JobPosting",
    title,
    description,
    datePosted,
    hiringOrganization: processHiringOrganization(hiringOrganization),
    ...jobLocation && {
      jobLocation: Array.isArray(jobLocation) ? jobLocation.map(processJobLocation) : processJobLocation(jobLocation)
    },
    ...url && { url },
    ...validThrough && { validThrough },
    ...employmentType && {
      employmentType: Array.isArray(employmentType) ? employmentType : employmentType
    },
    ...identifier && {
      identifier: processJobPropertyValue(identifier)
    },
    ...baseSalary && {
      baseSalary: processMonetaryAmount(baseSalary)
    },
    ...applicantLocationRequirements && {
      applicantLocationRequirements: Array.isArray(
        applicantLocationRequirements
      ) ? applicantLocationRequirements.map(
        processApplicantLocationRequirements
      ) : processApplicantLocationRequirements(applicantLocationRequirements)
    },
    ...jobLocationType && { jobLocationType },
    ...directApply !== void 0 && { directApply },
    ...educationRequirements && {
      educationRequirements: Array.isArray(educationRequirements) ? educationRequirements.map(processEducationRequirements) : processEducationRequirements(educationRequirements)
    },
    ...experienceRequirements && {
      experienceRequirements: processExperienceRequirements(
        experienceRequirements
      )
    },
    ...experienceInPlaceOfEducation !== void 0 && {
      experienceInPlaceOfEducation
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "jobposting-jsonld"
    }
  );
}

// src/components/DiscussionForumPostingJsonLd.tsx
var import_jsx_runtime20 = require("react/jsx-runtime");
function DiscussionForumPostingJsonLd({
  type = "DiscussionForumPosting",
  scriptId,
  scriptKey,
  headline,
  text,
  image,
  video,
  author,
  datePublished,
  dateModified,
  url,
  comment,
  creativeWorkStatus,
  interactionStatistic,
  isPartOf,
  sharedContent
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": type,
    ...headline && { headline },
    ...text && { text },
    ...image && {
      image: Array.isArray(image) ? image.map(processImage) : processImage(image)
    },
    ...video && { video: processVideo(video) },
    author: Array.isArray(author) ? author.map(processAuthor) : processAuthor(author),
    datePublished,
    ...dateModified && { dateModified },
    ...url && { url },
    ...comment && {
      comment: comment.map(processComment)
    },
    ...creativeWorkStatus && { creativeWorkStatus },
    ...interactionStatistic && {
      interactionStatistic: Array.isArray(interactionStatistic) ? interactionStatistic.map(processInteractionStatistic) : processInteractionStatistic(interactionStatistic)
    },
    ...isPartOf && { isPartOf: processIsPartOf(isPartOf) },
    ...sharedContent && {
      sharedContent: processSharedContent(sharedContent)
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || `${type.toLowerCase()}-jsonld`
    }
  );
}

// src/components/EmployerAggregateRatingJsonLd.tsx
var import_jsx_runtime21 = require("react/jsx-runtime");
function processEmployerItemReviewed(itemReviewed) {
  if (typeof itemReviewed === "string") {
    return {
      "@type": "Organization",
      name: itemReviewed
    };
  }
  const org = {
    "@type": "Organization",
    ...itemReviewed
  };
  if ("logo" in itemReviewed && itemReviewed.logo && typeof itemReviewed.logo !== "string") {
    org.logo = processLogo(itemReviewed.logo);
  }
  if ("address" in itemReviewed && itemReviewed.address) {
    if (Array.isArray(itemReviewed.address)) {
      org.address = itemReviewed.address.map(
        (addr) => typeof addr === "string" ? addr : processAddress(addr)
      );
    } else if (typeof itemReviewed.address !== "string") {
      org.address = processAddress(itemReviewed.address);
    }
  }
  if ("contactPoint" in itemReviewed && itemReviewed.contactPoint) {
    if (Array.isArray(itemReviewed.contactPoint)) {
      org.contactPoint = itemReviewed.contactPoint.map(processContactPoint);
    } else {
      org.contactPoint = processContactPoint(itemReviewed.contactPoint);
    }
  }
  if ("numberOfEmployees" in itemReviewed && itemReviewed.numberOfEmployees) {
    org.numberOfEmployees = processNumberOfEmployees(
      itemReviewed.numberOfEmployees
    );
  }
  return org;
}
function EmployerAggregateRatingJsonLd({
  scriptId,
  scriptKey,
  itemReviewed,
  ratingValue,
  ratingCount,
  reviewCount,
  bestRating,
  worstRating
}) {
  if (!ratingCount && !reviewCount) {
    throw new Error(
      "EmployerAggregateRating requires at least one of ratingCount or reviewCount"
    );
  }
  const data = {
    "@context": "https://schema.org",
    "@type": "EmployerAggregateRating",
    itemReviewed: processEmployerItemReviewed(itemReviewed),
    ratingValue,
    ...ratingCount && { ratingCount },
    ...reviewCount && { reviewCount },
    ...bestRating !== void 0 && { bestRating },
    ...worstRating !== void 0 && { worstRating }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "employer-aggregate-rating-jsonld"
    }
  );
}

// src/components/VacationRentalJsonLd.tsx
var import_jsx_runtime22 = require("react/jsx-runtime");
function VacationRentalJsonLd({
  scriptId,
  scriptKey,
  containsPlace,
  identifier,
  image,
  latitude,
  longitude,
  name,
  additionalType,
  address,
  aggregateRating,
  brand,
  checkinTime,
  checkoutTime,
  description,
  knowsLanguage,
  review,
  geo
}) {
  const processedImages = Array.isArray(image) ? image.map(processImage) : [processImage(image)];
  const finalLatitude = geo?.latitude ?? latitude;
  const finalLongitude = geo?.longitude ?? longitude;
  const data = {
    "@context": "https://schema.org",
    "@type": "VacationRental",
    containsPlace: processAccommodation(containsPlace),
    identifier,
    image: processedImages,
    latitude: finalLatitude,
    longitude: finalLongitude,
    name,
    ...additionalType && { additionalType },
    ...address && { address: processAddress(address) },
    ...aggregateRating && {
      aggregateRating: processAggregateRating(aggregateRating)
    },
    ...brand && { brand: processBrand(brand) },
    ...checkinTime && { checkinTime },
    ...checkoutTime && { checkoutTime },
    ...description && { description },
    ...knowsLanguage && {
      knowsLanguage: Array.isArray(knowsLanguage) ? knowsLanguage : [knowsLanguage]
    },
    ...review && {
      review: Array.isArray(review) ? review.map(processReview) : processReview(review)
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "vacationrental-jsonld"
    }
  );
}

// src/components/VideoJsonLd.tsx
var import_jsx_runtime23 = require("react/jsx-runtime");
function VideoJsonLd({
  type = "VideoObject",
  scriptId,
  scriptKey,
  name,
  description,
  thumbnailUrl,
  uploadDate,
  contentUrl,
  embedUrl,
  duration,
  expires,
  interactionStatistic,
  regionsAllowed,
  ineligibleRegion,
  publication,
  hasPart,
  potentialAction,
  author,
  publisher
}) {
  const data = {
    "@context": "https://schema.org",
    "@type": type,
    name,
    description,
    thumbnailUrl: Array.isArray(thumbnailUrl) ? thumbnailUrl.map(processImage) : processImage(thumbnailUrl),
    uploadDate,
    ...contentUrl && { contentUrl },
    ...embedUrl && { embedUrl },
    ...duration && { duration },
    ...expires && { expires },
    ...interactionStatistic && {
      interactionStatistic: Array.isArray(interactionStatistic) ? interactionStatistic.map(processInteractionStatistic) : processInteractionStatistic(interactionStatistic)
    },
    ...regionsAllowed && {
      regionsAllowed: Array.isArray(regionsAllowed) ? regionsAllowed : [regionsAllowed]
    },
    ...ineligibleRegion && {
      ineligibleRegion: Array.isArray(ineligibleRegion) ? ineligibleRegion : [ineligibleRegion]
    },
    ...publication && {
      publication: Array.isArray(publication) ? publication.map(processBroadcastEvent) : processBroadcastEvent(publication)
    },
    ...hasPart && {
      hasPart: Array.isArray(hasPart) ? hasPart.map(processClip) : processClip(hasPart)
    },
    ...potentialAction && {
      potentialAction: processSeekToAction(potentialAction)
    },
    ...author && {
      author: Array.isArray(author) ? author.map(processAuthor) : processAuthor(author)
    },
    ...publisher && { publisher: processPublisher(publisher) }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || `video-jsonld-${type}`
    }
  );
}

// src/components/ProfilePageJsonLd.tsx
var import_jsx_runtime24 = require("react/jsx-runtime");
function ProfilePageJsonLd({
  mainEntity,
  dateCreated,
  dateModified,
  scriptId,
  scriptKey
}) {
  const processedMainEntity = processAuthor(mainEntity);
  if (processedMainEntity.interactionStatistic) {
    if (Array.isArray(processedMainEntity.interactionStatistic)) {
      processedMainEntity.interactionStatistic = processedMainEntity.interactionStatistic.map(
        processInteractionStatistic
      );
    } else {
      processedMainEntity.interactionStatistic = processInteractionStatistic(
        processedMainEntity.interactionStatistic
      );
    }
  }
  if (processedMainEntity.agentInteractionStatistic) {
    processedMainEntity.agentInteractionStatistic = processInteractionStatistic(
      processedMainEntity.agentInteractionStatistic
    );
  }
  const data = {
    "@context": "https://schema.org",
    "@type": "ProfilePage",
    mainEntity: processedMainEntity,
    ...dateCreated && { dateCreated },
    ...dateModified && { dateModified }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "profile-page-jsonld"
    }
  );
}

// src/components/SoftwareApplicationJsonLd.tsx
var import_jsx_runtime25 = require("react/jsx-runtime");
function SoftwareApplicationJsonLd({
  type = "SoftwareApplication",
  scriptId,
  scriptKey,
  name,
  description,
  url,
  image,
  applicationCategory,
  applicationSubCategory,
  applicationSuite,
  operatingSystem,
  memoryRequirements,
  processorRequirements,
  storageRequirements,
  availableOnDevice,
  downloadUrl,
  installUrl,
  countriesSupported,
  countriesNotSupported,
  permissions,
  softwareVersion,
  releaseNotes,
  screenshot,
  featureList,
  offers,
  aggregateRating,
  review,
  author,
  publisher,
  datePublished,
  dateModified,
  contentRating
}) {
  let schemaType;
  if (Array.isArray(type)) {
    schemaType = type;
  } else {
    schemaType = type;
  }
  const data = {
    "@context": "https://schema.org",
    "@type": schemaType,
    // Required properties
    ...name && { name },
    // Conditionally include properties
    ...description && { description },
    ...url && { url },
    ...image && {
      image: Array.isArray(image) ? image.map(processImage) : processImage(image)
    },
    ...applicationCategory && { applicationCategory },
    ...applicationSubCategory && { applicationSubCategory },
    ...applicationSuite && { applicationSuite },
    ...operatingSystem && { operatingSystem },
    ...memoryRequirements && { memoryRequirements },
    ...processorRequirements && { processorRequirements },
    ...storageRequirements && { storageRequirements },
    ...availableOnDevice && { availableOnDevice },
    ...downloadUrl && { downloadUrl },
    ...installUrl && { installUrl },
    ...countriesSupported && {
      countriesSupported: Array.isArray(countriesSupported) ? countriesSupported : countriesSupported
    },
    ...countriesNotSupported && {
      countriesNotSupported: Array.isArray(countriesNotSupported) ? countriesNotSupported : countriesNotSupported
    },
    ...permissions && {
      permissions: processFeatureList(permissions)
    },
    ...softwareVersion && { softwareVersion },
    ...releaseNotes && { releaseNotes },
    ...screenshot && {
      screenshot: Array.isArray(screenshot) ? screenshot.map(processScreenshot) : processScreenshot(screenshot)
    },
    ...featureList && {
      featureList: processFeatureList(featureList)
    },
    ...offers && {
      offers: Array.isArray(offers) ? offers.map(processOffer) : processOffer(offers)
    },
    ...aggregateRating && {
      aggregateRating: processAggregateRating(aggregateRating)
    },
    ...review && {
      review: Array.isArray(review) ? review.map(processReview) : processReview(review)
    },
    ...author && {
      author: processAuthor(author)
    },
    ...publisher && {
      publisher: processPublisher(publisher)
    },
    ...datePublished && { datePublished },
    ...dateModified && { dateModified },
    // Apply defaults where appropriate
    ...!dateModified && datePublished && { dateModified: datePublished },
    ...contentRating && { contentRating }
  };
  const typeKey = Array.isArray(schemaType) ? schemaType.join("-").toLowerCase() : schemaType.toLowerCase();
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || `software-application-jsonld-${typeKey}`
    }
  );
}

// src/components/ProductJsonLd.tsx
var import_jsx_runtime26 = require("react/jsx-runtime");
function ProductJsonLd(props) {
  const { scriptId, scriptKey, ...rest } = props;
  const isProductGroup = "type" in rest && rest.type === "ProductGroup" || "hasVariant" in rest || "variesBy" in rest || "productGroupID" in rest;
  let data;
  if (isProductGroup) {
    const groupProps = rest;
    data = {
      "@context": "https://schema.org",
      "@type": "ProductGroup",
      name: groupProps.name,
      ...groupProps.description && { description: groupProps.description },
      ...groupProps.url && { url: groupProps.url },
      ...groupProps.image && {
        image: Array.isArray(groupProps.image) ? groupProps.image.map(processImage) : processImage(groupProps.image)
      },
      ...groupProps.brand && {
        brand: typeof groupProps.brand === "string" ? { "@type": "Brand", name: groupProps.brand } : processBrand(groupProps.brand)
      },
      ...groupProps.review && {
        review: Array.isArray(groupProps.review) ? groupProps.review.map(processProductReview) : processProductReview(groupProps.review)
      },
      ...groupProps.aggregateRating && {
        aggregateRating: processAggregateRating(groupProps.aggregateRating)
      },
      ...groupProps.audience && { audience: groupProps.audience },
      productGroupID: groupProps.productGroupID,
      ...groupProps.variesBy && {
        variesBy: processVariesBy(groupProps.variesBy)
      },
      ...groupProps.hasVariant && {
        hasVariant: groupProps.hasVariant.map(processProductVariant)
      },
      ...groupProps.pattern && { pattern: groupProps.pattern },
      ...groupProps.material && { material: groupProps.material },
      ...groupProps.category && { category: groupProps.category }
    };
  } else {
    const productProps = rest;
    if (!productProps.review && !productProps.aggregateRating && !productProps.offers && !productProps.isVariantOf) {
      console.warn(
        "ProductJsonLd: Product structured data requires at least one of: review, aggregateRating, offers, or isVariantOf"
      );
    }
    let processedOffers;
    if (productProps.offers) {
      if (Array.isArray(productProps.offers)) {
        processedOffers = productProps.offers.map((offer) => {
          if ("lowPrice" in offer && "priceCurrency" in offer) {
            return processAggregateOffer(
              offer
            );
          }
          return processProductOffer(offer);
        });
      } else if ("lowPrice" in productProps.offers && "priceCurrency" in productProps.offers) {
        processedOffers = processAggregateOffer(
          productProps.offers
        );
      } else {
        processedOffers = processProductOffer(productProps.offers);
      }
    }
    let processedReview;
    if (productProps.review) {
      processedReview = Array.isArray(productProps.review) ? productProps.review.map(processProductReview) : processProductReview(productProps.review);
    }
    let processedBrand;
    if (productProps.brand) {
      if (typeof productProps.brand === "string") {
        processedBrand = {
          "@type": "Brand",
          name: productProps.brand
        };
      } else {
        processedBrand = processBrand(productProps.brand);
      }
    }
    const processQuantitativeValue2 = (value) => {
      if (typeof value === "string") {
        return value;
      }
      if (value && typeof value === "object" && !("@type" in value)) {
        return {
          "@type": "QuantitativeValue",
          ...value
        };
      }
      return value;
    };
    data = {
      "@context": "https://schema.org",
      "@type": productProps.isCar ? ["Product", "Car"] : "Product",
      name: productProps.name,
      ...productProps.description && {
        description: productProps.description
      },
      ...productProps.image && {
        image: Array.isArray(productProps.image) ? productProps.image.map(processImage) : processImage(productProps.image)
      },
      ...productProps.sku && { sku: productProps.sku },
      ...productProps.mpn && { mpn: productProps.mpn },
      ...productProps.gtin && { gtin: productProps.gtin },
      ...productProps.gtin8 && { gtin8: productProps.gtin8 },
      ...productProps.gtin12 && { gtin12: productProps.gtin12 },
      ...productProps.gtin13 && { gtin13: productProps.gtin13 },
      ...productProps.gtin14 && { gtin14: productProps.gtin14 },
      ...processedBrand && { brand: processedBrand },
      ...processedReview && { review: processedReview },
      ...productProps.aggregateRating && {
        aggregateRating: processAggregateRating(productProps.aggregateRating)
      },
      ...processedOffers && { offers: processedOffers },
      ...productProps.category && { category: productProps.category },
      ...productProps.color && { color: productProps.color },
      ...productProps.material && { material: productProps.material },
      ...productProps.model && { model: productProps.model },
      ...productProps.productID && { productID: productProps.productID },
      ...productProps.url && { url: productProps.url },
      ...productProps.weight && {
        weight: processQuantitativeValue2(productProps.weight)
      },
      ...productProps.width && {
        width: processQuantitativeValue2(productProps.width)
      },
      ...productProps.height && {
        height: processQuantitativeValue2(productProps.height)
      },
      ...productProps.depth && {
        depth: processQuantitativeValue2(productProps.depth)
      },
      ...productProps.additionalProperty && {
        additionalProperty: productProps.additionalProperty
      },
      ...productProps.manufacturer && {
        manufacturer: processAuthor(productProps.manufacturer)
      },
      ...productProps.releaseDate && {
        releaseDate: productProps.releaseDate
      },
      ...productProps.productionDate && {
        productionDate: productProps.productionDate
      },
      ...productProps.purchaseDate && {
        purchaseDate: productProps.purchaseDate
      },
      ...productProps.expirationDate && {
        expirationDate: productProps.expirationDate
      },
      ...productProps.award && { award: productProps.award },
      ...productProps.size && {
        size: processSizeSpecification(productProps.size)
      },
      ...productProps.pattern && { pattern: productProps.pattern },
      ...productProps.isbn && { isbn: productProps.isbn },
      ...productProps.hasCertification && {
        hasCertification: Array.isArray(productProps.hasCertification) ? productProps.hasCertification.map(processCertification) : processCertification(productProps.hasCertification)
      },
      ...productProps.audience && {
        audience: processPeopleAudience(productProps.audience)
      },
      ...productProps.subjectOf && {
        subjectOf: processThreeDModel(productProps.subjectOf)
      },
      ...productProps.isVariantOf && {
        isVariantOf: productProps.isVariantOf
      },
      ...productProps.inProductGroupWithID && {
        inProductGroupWithID: productProps.inProductGroupWithID
      }
    };
  }
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || (isProductGroup ? "productgroup-jsonld" : "product-jsonld")
    }
  );
}

// src/components/ReviewJsonLd.tsx
var import_jsx_runtime27 = require("react/jsx-runtime");
function ReviewJsonLd({
  scriptId,
  scriptKey,
  author,
  reviewRating,
  itemReviewed,
  datePublished,
  reviewBody,
  publisher,
  url,
  mainEntityOfPage
}) {
  if (!author) {
    throw new Error("Review requires an author");
  }
  const ratingValue = typeof reviewRating === "object" && reviewRating ? reviewRating.ratingValue : void 0;
  if (ratingValue === void 0) {
    throw new Error("Review requires reviewRating.ratingValue");
  }
  if (!itemReviewed) {
    throw new Error("Review requires itemReviewed when used standalone");
  }
  const data = {
    "@context": "https://schema.org",
    "@type": "Review",
    author: processAuthor(author),
    reviewRating: {
      "@type": "Rating",
      ...reviewRating
    },
    itemReviewed: processItemReviewed(itemReviewed),
    ...datePublished && { datePublished },
    ...reviewBody && { reviewBody },
    ...publisher && { publisher: processPublisher(publisher) },
    ...url && { url },
    ...mainEntityOfPage && {
      mainEntityOfPage: processMainEntityOfPage(mainEntityOfPage)
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "review-jsonld"
    }
  );
}

// src/components/AggregateRatingJsonLd.tsx
var import_jsx_runtime28 = require("react/jsx-runtime");
function AggregateRatingJsonLd({
  scriptId,
  scriptKey,
  itemReviewed,
  ratingValue,
  ratingCount,
  reviewCount,
  bestRating,
  worstRating
}) {
  if (!itemReviewed) {
    throw new Error(
      "AggregateRating requires itemReviewed when used standalone"
    );
  }
  if (!ratingCount && !reviewCount) {
    throw new Error(
      "AggregateRating requires at least one of ratingCount or reviewCount"
    );
  }
  const data = {
    "@context": "https://schema.org",
    "@type": "AggregateRating",
    itemReviewed: processItemReviewed(itemReviewed),
    ratingValue,
    ...ratingCount !== void 0 && { ratingCount },
    ...reviewCount !== void 0 && { reviewCount },
    ...bestRating !== void 0 && { bestRating },
    ...worstRating !== void 0 && { worstRating }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
    JsonLdScript,
    {
      data,
      id: scriptId,
      scriptKey: scriptKey || "aggregaterating-jsonld"
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AggregateRatingJsonLd,
  ArticleJsonLd,
  BreadcrumbJsonLd,
  CarouselJsonLd,
  ClaimReviewJsonLd,
  CourseJsonLd,
  CreativeWorkJsonLd,
  DatasetJsonLd,
  DiscussionForumPostingJsonLd,
  EmployerAggregateRatingJsonLd,
  EventJsonLd,
  FAQJsonLd,
  HowToJsonLd,
  ImageJsonLd,
  JobPostingJsonLd,
  JsonLdScript,
  LocalBusinessJsonLd,
  MerchantReturnPolicyJsonLd,
  MovieCarouselJsonLd,
  OrganizationJsonLd,
  ProductJsonLd,
  ProfilePageJsonLd,
  QuizJsonLd,
  RecipeJsonLd,
  ReviewJsonLd,
  SoftwareApplicationJsonLd,
  VacationRentalJsonLd,
  VideoJsonLd,
  processors
});
//# sourceMappingURL=index.js.map